---
layout: single
title: "JPA란?"
categories: "Spring_JPA0"
tags: [Spring, Java, JPA, Basic, 김영한강의]
toc: true
toc_sticky: true
toc_label: "목차"
---

이번 글에서는 JPA(Java Persistence API)가 무엇인지 알아보려고합니다. JPA는 자바 진영에서 ORM(Object-Relational Mapping) 기술 표준으로 사용되는 인터페이스의 모음입니다.

우선 ORM에 대해 알아보도록 합시다.

<br>

> # 🪢ORM이란?

ORM(Object-Relational Mapping)은 객체 지향 프로그래밍 언어와 관계형 데이터베이스 간의 데이터를 변환하고 매핑하기 위한 기술입니다.

> # ORM의 장단점

## 장점

### 1. 완벽한 객체지향적인 코드

- ORM을 이용하면 SQL문이 아닌 클래스의 메서드를 통해 데이터베이스를 조작할 수 있어, 개발자가 객체 모델만 이용해서 프로그래밍을 하는 데 집중할 수 있게한다.
- SQL 문을 사용하면서 같이 필요한 선언문, 할당, 종료 같은 부수적인 코드가 사라지거나 줄어들며, 각종 객체에 대한 코드를 별도로 작성하여 코드의 가독성을 높일 수 있다.
- 객체지향적 접근과 SQL의 절차적/순차적 접근이 혼재되어있던 기존 방식과 달리 오직 객체지향적 접근만 고려하면 되기때문에 생산성이 증가한다.

---

### 2. 재사용, 유지보수, 리팩토링 용이성

ORM은 기존 객체와 독립적으로 작성되어있고, 객체로 작성되었기 때문에 재활용할 수 있다. 또한, 매핑하는 정보가 명확하기 때문에 ERD를 보는 의존도를 낮출 수 있다.

---

### 3. DBMS(DataBase Management System) 종속성 하락

- 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하고, 객체의 자료형 타입까지 사용할 수 있기 때문에 RDBMS의 데이터 구조와 객체지향 모델 사이의 간격을 좁힐 수 있다.
- 객체에만 집중할 수 있기 때문에 DBMS를 교체하는 큰 작업에도 리스크가 적고 드는 시간도 줄어든다. 예들 들어 자바에서 가공할 경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠르게 가공할 수 있다.

## 단점

### 1. ORM이 모든 걸 해결해줄 수 없다.

ORM을 사용하는 것은 매우 편리하지만 그만큼 신중하게 설계해야한다. 프로젝트의 복잡성이 커질 수록 난이도도 올라가고 부족한 설계로 잘못 구현되었을 경우 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있다. 또한 일부 자주 사용되는 대형 SQL문은 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 써야할 수도 있다.

---

### 2. 객체-관계 간의 불일치

- 세분성(Granularity)  
  경우에 따라서 데이터베이스에 있는 테이블 수보다 더 많은 클래스를 가진 모델이 생길 수 있다.

- 상속성(Inheritance)  
  RDBMS는 객체지향 프로그래밍 언어의 특징인 상속 개념이 없다.

- 일치(Identity)  
  RDBMS는 기본키(primary key)를 이용하여 동일성을 정의한다. 그러나 자바는 객체 식별(a==b)과 객체 동일성(a.equals(b))을 모두 정의한다.

- 연관성(Associations)  
  객체지향 언어는 방향성이 있는 객체의 참조(reference)를 사용하여 연관성을 나타내지만 RDBMS는 방향성이 없는 외래키(foreign key)를 이용해서 나타낸다.

- 탐색(Navigation)  
  자바와 RDBMS에서 객체를 접근하는 방법이 근본적으로 다르다. 자바는 그래프형태로 하나의 연결에서 다른 연결로 이동하며 탐색한다. 그러나 RDBMS에서는 일반적으로 SQL문을 최소화하고 JOIN을 통해 여러 엔티티를 로드하고 원하는 대상 엔티티를 선택하는 방식으로 탐색한다.

<br/><br/>

> # JPA란?

JPA(Java Persistence API)는 자바 진영의 ORM(Object-Relational Mapping) 표준 기술로, 자바 애플리케이션에서 관계형 데이터베이스의 데이터를 객체 지향적으로 관리하기 위한 표준 인터페이스를 제공합니다.  
 (현재는 주로 관계형 데이터베이스(RDB)를 사용하며, 필요한 경우에만 NoSQL을 추가로 사용합니다.)
![JPA](../../images/2023-04-08-infrun01/JPA.png)

> # JPA의 발전

JPA는 EJB(Enterprise JavaBeans)의 문제점을 보완하기 위해 시작되었습니다. 하이버네이트와 같은 오픈 소스 ORM 프레임워크의 출현으로, 자바 진영은 JPA라는 표준을 발표하였고, 이후 버전 업그레이드를 통해 지속적으로 발전해왔습니다. JPA의 표준 명세는 하이버네이트, EclipseLink, DataNucleus 등 여러 구현체가 존재합니다.

> # JPA를 왜 써야하는가?

## SQL 중심적인 개발

### 1) 같은 코드의 무한 반복 → sql 코드, 기본 CRUD의 반복

### 2) 패러다임의 불일치 : 객체와 관계형 DB의 차이 → 객체를 DB에 넣을 때 문제 발생

1. 상속  
   객체랑 다르게 테이블은 상속이라는 기능이 없어서, 개발자가 여러 설정/쿼리를 생성했어야함 → JPA에서는 여러 쿼리를 한번에 실행해서 해결, 마치 자바 컬렉션처럼!

2. 연관관계  
   객체는 참조를 사용해서 연관된 객체를 조회하는 데, 테이블은 외래키로 연관관계를 설정하고 조인으로 연관 테이블을 조회함

   ```java
   //원래의 객체 지향 방식
   class Member {
      String id; //MEMBER_ID 컬럼 사용
      Team team; //참조로 연관관계를 맺는다. => Long teamId; 테이블처럼 바꿀 경우
      String username;//USERNAME 컬럼 사용
      Team getTeam() {
          return team;
      }
   }
   class Team {
      Long id; //TEAM_ID PK 사용
      String name; //NAME 컬럼 사용
   }
   ```

3. 객체 그래프 탐색  
   객체 그래프가 어디까지 탐색할 수 있는 지는 SQL을 사용해보아야 한다. (알겠지만 헷갈림) → JPA는 실제 객체를 사용하는 시점까지 DB조회를 미룬다(지연로딩). 따라서 연관된 객체를 신뢰하고 조회할 수 있음!

   ```java
   Member member = jpa.find(Member.class, memberId); //최초에 select 쿼리 발생

   Order oreder = memeber.getOrder();
   order.getOrderDate(); //order를 사용하는 시점에 select 쿼리 발생! -> 지연로딩
   ```

4. 비교  
   DB는 PK(기본 키)로 각 row를 구분하는 반면, 객체는 동일성/동등성 비교를 한다.

   ```java
   String memberId = "100";
   Member member1 = memberDAO.getMember(memberId);
   Member member2 = memberDAO.getMember(memberId);

   member1 == member2; //다르다.
   // DB에서 같은 row를 조회했지만,
   // 객체 입장에서는 new로 생성된 각각 다른 인스턴스이기때문에 다른값으로 나옴
   ```

   → JPA는 DB의 같은 로우를 조회할 경우, 1차 캐시로 동일성 비교를 보장한다

> # JPA의 성능문제

JPA는 동적이기 때문에 성능문제가 있을 수 있습니다. 아래는 성능을 최적화 할 수 있는 전략 및 문제입니다.

## 캐싱 전략

캐싱은 데이터베이스에서 조회한 데이터를 메모리에 저장해 놓고, 동일한 요청이 들어올 경우 데이터베이스에 다시 접근하지 않고 메모리에서 읽어오는 방식입니다. 이를 통해 데이터베이스와의 통신 비용이 감소하고 성능이 향상됩니다. JPA에서는 주로 두 가지 캐시를 사용합니다.

- 1차 캐시 (First-Level Cache): 트랜잭션 범위의 캐시로, 영속성 컨텍스트 내에서만 유효합니다. 엔티티를 조회하면 자동으로 1차 캐시에 저장되며, 같은 트랜잭션 내에서 동일한 엔티티를 조회할 경우 1차 캐시에서 읽어옵니다.
- 2차 캐시 (Second-Level Cache): 애플리케이션 범위의 캐시로, 여러 영속성 컨텍스트에서 공유됩니다. 자주 조회되는 데이터를 2차 캐시에 저장해두면 여러 트랜잭션에서 데이터베이스에 접근하지 않고 캐시에서 데이터를 읽어올 수 있어 성능이 향상됩니다.

## FetchType 설정

FetchType은 엔티티의 연관된 다른 엔티티를 언제 가져올지 결정하는 설정입니다. FetchType에는 크게 두 가지 옵션이 있습니다.

- EAGER (즉시 로딩): 연관된 엔티티를 처음부터 함께 로드합니다. 연관 엔티티를 항상 사용할 경우에 적합하며, 쿼리 수를 줄일 수 있습니다.
- LAZY (지연 로딩): 연관된 엔티티를 실제로 사용할 때 로드합니다. 연관 엔티티를 가끔 사용하거나, 큰 데이터를 가진 경우에 적합합니다. 필요한 시점에만 데이터를 로드함으로써 성능을 향상시킬 수 있습니다.

## N+1 문제 해결

N+1 문제는 하나의 엔티티와 관련된 여러 개의 연관된 엔티티를 조회할 때 발생하는 성능 저하 문제입니다. 기본적으로 JPA는 연관된 엔티티를 가져올 때 각각의 엔티티에 대해 쿼리를 수행합니다. 이로 인해 쿼리이로 인해 쿼리가 과도하게 많아져 성능이 저하될 수 있습니다. N+1 문제를 해결하는 방법은 다음과 같습니다.

- JOIN FETCH: JPQL (Java Persistence Query Language)에서 JOIN FETCH 구문을 사용하면, 한 번의 쿼리로 필요한 연관 엔티티를 함께 조회할 수 있습니다. 이를 통해 쿼리 수를 줄이고 성능을 개선할 수 있습니다.

- 엔티티 그래프 (Entity Graph): JPA 2.1부터 도입된 엔티티 그래프를 사용하면, 조회할 엔티티와 함께 로드할 연관 엔티티를 명시적으로 지정할 수 있습니다. 이를 통해 필요한 데이터만 쿼리로 가져올 수 있으며, 성능을 개선할 수 있습니다.

- 일대다 (OneToMany) 관계에서는 일대다 연관 필드를 지연 로딩 (FetchType.LAZY)으로 설정하는 것이 좋습니다. 이렇게 하면 연관된 엔티티를 필요할 때만 로드하므로, 쿼리 수를 줄이고 성능을 개선할 수 있습니다.

> # 참고

## 1. 1차 캐시의 성능 문제

1차 캐시를 사용하면 영속성 컨텍스트 내에서 데이터를 캐시에서 가져오기 때문에, 이론적으로 일부 추가적인 시간이 소요될 수 있습니다. 그러나 실제로 1차 캐시에서 값을 가져오는 비용은 데이터베이스와의 통신 비용에 비해 상대적으로 매우 작습니다.

영속성 컨텍스트의 1차 캐시는 트랜잭션 범위에 속하며, 트랜잭션 내에서 동일한 엔티티를 여러 번 조회할 경우 데이터베이스와의 통신 없이 캐시에서 데이터를 가져올 수 있습니다. 이로 인해 데이터베이스와의 통신 비용이 줄어들고 성능이 개선됩니다.

또한, 1차 캐시에서 값을 찾는 과정은 해시 기반의 맵 자료구조를 사용하기 때문에, 일반적으로 O(1)의 시간 복잡도를 가집니다. 따라서 캐시에서 값을 찾는 시간은 상대적으로 빠르게 처리됩니다.

결론적으로, 1차 캐시를 사용하여 값을 찾는 추가적인 시간이 소요되더라도, 이는 데이터베이스와의 통신 비용에 비해 상대적으로 작은 비용입니다. 이로 인해 전체적인 성능 향상을 기대할 수 있습니다.
