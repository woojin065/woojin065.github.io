---
title: 인덱스
date: 2025-02-08 00:12:00 +09:00
categories: [common_topic]
tags: [common]
image: 
  path: /images/2025/2-8-TIndex.png
  hidden: true  # 본문에서 미리보기 이미지를 숨김
---
## 1. 인덱스(Index)란 무엇인가?

### 인덱스의 정의와 개념

인덱스(Index)는 데이터베이스 테이블에 저장된 데이터를 빠르게 검색하기 위해 추가적으로 생성하는 자료구조입니다. 책의 목차를 떠올리면 이해하기 쉬운데, 원하는 내용을 빠르게 찾아갈 수 있도록 정보를 ‘정렬된 형태’로 미리 구성해두는 역할을 합니다.

### 인덱스의 필요성

- **검색 속도 향상**: 대용량 테이블에서 원하는 레코드를 빠르게 찾을 수 있습니다.
- **데이터 처리 비용 절감**: WHERE 절, JOIN, ORDER BY, GROUP BY 등의 연산이 효율적으로 수행됩니다.
- **시스템 리소스 절약**: 테이블 전체 스캔(Table Scan)을 줄여 CPU, 메모리, 디스크 I/O 활용을 최적화합니다.

### 인덱스를 사용하지 않았을 때의 문제점

- **느린 쿼리 응답**: 모든 데이터를 스캔해야 하므로 검색 속도가 떨어집니다.
- **시스템 부담 증가**: 불필요한 I/O 연산이 많아져 데이터베이스 서버에 부하가 가중됩니다.
- **스케일링 한계**: 사용자가 많아지거나 데이터량이 폭증할 경우 성능이 급격히 저하됩니다.

---

## 2. 인덱스 동작 원리

### 2.1 인덱스 자료구조 개요

### B+ 트리 인덱스

대부분의 RDBMS에서 사용하는 대표적인 인덱스 구조로, B-Tree에서 파생된 자료구조입니다.

- **B+ 트리와 B-Tree 비교**:
    - B-Tree는 모든 노드에 데이터가 존재하지만, **B+ 트리는 실제 데이터(레코드에 대한 포인터)가 리프(leaf) 노드에만** 존재합니다.
    - 리프 노드들이 연결된 링크드 리스트 형태로 구성되어 범위 탐색(Range Scan)에 뛰어난 성능을 보입니다.
- **B+ 트리 구조(Leaf Node, Internal Node)**:
    - **Internal Node(내부 노드)**: 검색 경로를 안내하는 키(key)와 포인터(pointer)로 구성됩니다.
    - **Leaf Node(리프 노드)**: 실제 테이블 레코드에 대한 포인터(혹은 해당 키의 데이터)를 보유합니다.
- **삽입, 삭제, 검색 과정**:
    - **검색**: 루트 노드에서 시작해 키 범위를 비교하며 리프 노드까지 내려간 뒤, 데이터에 직접 접근합니다.
    - **삽입/삭제**: 리프 노드에 데이터를 추가/제거하며, 노드가 가득 찰 경우 분할(split) 또는 병합(merge)을 통해 트리 균형을 유지합니다.

### Hash 인덱스

- **해시 함수를 통한 빠른 검색**: 키를 해시 함수로 변환해 특정 버킷(bucket)에 저장하는 방식입니다.
- **충돌 처리 방식**: 동일한 해시 값을 갖는 레코드가 여러 개일 경우 체이닝(Chaining) 또는 오버플로우 버킷 등을 통해 관리합니다.
- **장단점**: 해시 계산이 빠르지만, 범위 검색에 적합하지 않습니다. (= “=“ 연산(정확한 매칭)에는 좋지만 “<”, “>” 등 범위 연산은 비효율적)

### 기타 인덱스 (R-Tree, Bitmap 등)

- **R-Tree**: 공간(Spatial) 데이터를 다루는 데 자주 사용 (GIS, 좌표 검색 등)
- **Bitmap Index**: 엔트로피가 낮은(카디널리티가 낮은) 컬럼에 효과적 (예: 성별, 지역코드)

### 2.2 검색 과정과 인덱스 활용

- **쿼리 실행 시 B+ 트리 기반의 탐색 원리**:
    1. DB 엔진은 인덱스 키를 통해 B+ 트리의 루트 노드부터 검색을 시작합니다.
    2. 키 범위 비교로 Internal Node를 거쳐 Leaf Node에 도달합니다.
    3. Leaf Node에서 실제 데이터 위치를 찾아 테이블을 참조합니다.
- **해시 인덱스 검색과 비교**:
    - 해시 인덱스는 특정 해시 함수를 통해 곧바로 버킷을 찾는 방식이므로 ‘정확한 값’ 검색에 강점이 있습니다.
    - 다만 범위 검색이나 정렬이 필요한 경우 해시 인덱스는 비효율적입니다.

---

## 3. 인덱스의 종류

### Clustered Index(클러스터드 인덱스)

- **물리적 정렬과 테이블 데이터 정렬**: 테이블 자체가 인덱스 구조로 조직화되어, 인덱스가 곧 데이터 저장 순서를 결정합니다.
- **장단점**:
    - 장점: 범위 검색 시 디스크 I/O를 최소화할 수 있어 빠른 검색 가능
    - 단점: 데이터의 물리적 순서를 유지해야 하므로 삽입/삭제 시 오버헤드가 발생할 수 있음

### Non-Clustered Index(논클러스터드 인덱스)

- **별도의 인덱스 구조**: 실제 데이터가 저장된 테이블과는 별개로 인덱스 페이지가 존재합니다.
- **장단점**:
    - 장점: 필요한 컬럼만 인덱스로 만들기 쉬워, 다양한 쿼리 최적화 가능
    - 단점: 인덱스 페이지와 테이블 페이지를 모두 참조해야 하므로, 경우에 따라 추가 I/O 발생

### 기타 인덱스

- **Full-Text Index**: 문자열 전처리(토큰화, 형태소 분석 등)을 통해 전문(全文) 검색을 효율화
- **Unique Index**: 컬럼 값의 중복을 허용하지 않는 제약을 인덱스 레벨에서 보장

---

## 4. 인덱스 생성과 관리

### 인덱스 생성 문법과 예시 (SQL 기반)

```sql
-- MySQL 예시
CREATE INDEX idx_user_name
ON users (name);

-- PostgreSQL 예시
CREATE INDEX idx_post_title
ON posts (title);
```

### 인덱스 생성 시 고려해야 할 요소

- **인덱스 컬럼 선택**: 자주 검색되는(WHERE 절에서 사용되는) 컬럼을 우선적으로 고려합니다.
- **인덱스 길이와 데이터형**: 너무 긴 문자열(예: TEXT, CLOB 등)은 인덱스 효율을 떨어뜨릴 수 있으므로, 필요한 길이만 인덱싱하는 등 최적화가 필요합니다.

### 인덱스 삭제(DROP)와 재생성

- 인덱스가 불필요해졌거나 중복된 인덱스가 있는 경우, **`DROP INDEX`*를 통해 제거할 수 있습니다.
- 대규모 테이블에 변경사항이 많았다면, **인덱스 재생성**(Rebuild)을 통해 성능을 유지하기도 합니다.

### 인덱스 모니터링, 통계 갱신(Statistics Update)

- **인덱스 통계**는 쿼리 옵티마이저가 최적의 실행 계획을 수립하는 데 중요한 역할을 합니다.
- **자동/수동 갱신** 옵션을 통해 최신 통계 정보를 유지하도록 설정합니다.

---

## 5. 인덱스 튜닝 전략

### 인덱스 선택성(Selectivity)

- **높은 선택성을 가지는 컬럼 선택**: 중복도가 낮아, 검색 결과가 상대적으로 적은 컬럼에 인덱스를 만들면 효과적입니다.
- **다중 컬럼 인덱스(Multi-column Index) 전략**: 자주 함께 검색되는 컬럼들(예: `WHERE city = 'Seoul' AND age > 30`)을 복합 인덱스로 구성하는 것이 좋습니다.

### 카디널리티(Cardinality)와 통계

- **옵티마이저와 통계 활용**: DBMS 옵티마이저는 통계를 바탕으로 가장 적합한 쿼리 실행 계획을 수립합니다.
- 데이터 분포가 크게 변하면, **ANALYZE**(PostgreSQL)나 **OPTIMIZE TABLE**(MySQL) 등을 통해 통계를 갱신해줍니다.

### 과도한 인덱스 vs. 필요한 인덱스

- **인덱스 개수, 성능, 유지 비용 사이의 균형**: 인덱스가 많을수록 조회는 빨라질 수 있지만, 쓰기 연산(INSERT, UPDATE, DELETE) 시 성능이 떨어집니다. 테이블 구조와 사용 패턴에 맞춰 최적의 개수를 유지해야 합니다.

---

## 6. 쿼리 실행 계획과 인덱스 활용

### 인덱스 스캔(Index Scan)

- 인덱스의 전체(또는 범위)를 순차적으로 탐색하는 방식입니다. 선택도가 좋지 않으면 테이블 스캔과 큰 차이가 없을 수도 있습니다.

### 인덱스 시크(Index Seek)

- 인덱스 컬럼의 범위 혹은 키 값만을 좁혀서 탐색합니다. 보통 **Index Seek**가 **Index Scan**보다 효율적입니다.

### 테이블 스캔(Table Scan)와 비교

- 인덱스를 전혀 사용하지 않고 모든 레코드를 순차적으로 훑는 방식입니다. 작은 테이블이나 전체 검색(Full Table Scan)이 필요한 경우에는 오히려 빠를 수도 있지만, 대용량 테이블에서는 성능 저하를 일으킵니다.

### 쿼리 옵티마이저(Optimizer)가 인덱스를 선택하는 방식

- DB 엔진은 통계 정보(카디널리티 등)를 이용해 비용(cost)을 추정하고, 가장 빠를 것으로 예상되는 방법(인덱스 스캔, 인덱스 시크, 테이블 스캔 등)을 선택합니다.

---

## 7. 인덱스가 성능에 미치는 영향

### 조회(SELECT) 성능 향상

- B+ 트리 인덱스는 O(log n)의 검색 복잡도를 제공하므로, 데이터가 많아도 빠른 조회가 가능합니다.

### 쓰기(INSERT, UPDATE, DELETE) 성능 저하 이슈

- 인덱스가 많으면, 데이터를 변경할 때마다 모든 인덱스를 갱신해야 하므로 추가 비용이 발생합니다.

### 대용량 트랜잭션 환경에서의 주의점

- 대규모 배치 작업 또는 대량 INSERT 시, 인덱스 업데이트로 인해 시스템 성능이 저하될 수 있습니다.
- 경우에 따라 **인덱스를 임시로 비활성화**하거나 **배치 작업 후 재생성**하는 전략을 사용하기도 합니다.

---

## 9. 인덱스 관리 도구 및 모범 사례

### DBMS별(예: MySQL, PostgreSQL, Oracle, MSSQL 등) 인덱스 관리 툴

- **MySQL**: `SHOW INDEX FROM 테이블명`, `EXPLAIN` 키워드를 통한 실행 계획 확인
- **PostgreSQL**: `\d 인덱스명`, `EXPLAIN ANALYZE`로 실행 계획 및 실제 성능 측정
- **Oracle**: `ALL_INDEXES` 뷰, `EXPLAIN PLAN`
- **MSSQL**: SSMS(Management Studio)에서 인덱스 뷰 확인, `SHOWPLAN` 기능

### 모범 사례(Best Practices)

1. **정기적인 인덱스 재구성(리빌드)**: 인덱스가 조각화(fragmentation)되면 성능이 저하될 수 있으므로 주기적으로 점검합니다.
2. **자주 변경되는 테이블의 인덱스 전략**: 업데이트가 빈번한 컬럼에는 불필요하게 인덱스를 많이 만들지 않도록 주의합니다.
3. **통계 자동 업데이트 설정**: 데이터 분포 변화에 따라 통계를 주기적으로 최신화해야 옵티마이저가 올바른 실행 계획을 수립합니다.

---

## 10. 결론

### 인덱스 설계의 중요성

인덱스는 DB 성능 튜닝의 핵심 요소입니다. 적절히 사용하면 읽기 작업 속도가 혁신적으로 개선될 수 있지만, 관리 비용 또한 필연적으로 발생합니다.

### 적절한 인덱스 사용을 위한 요령 정리

- **쿼리 패턴 파악**: 어떤 쿼리가 자주 실행되는지(조회/집계/정렬 등)를 분석합니다.
- **높은 선택성 컬럼 우선**: 중복도가 낮은 컬럼에 인덱스를 설정해, 인덱스 효율을 높입니다.
- **과도한 인덱스 자제**: 인덱스가 많으면 쓰기 성능이 떨어지고, 관리가 복잡해집니다.
- **주기적 모니터링/통계 업데이트**: 실행 계획(EXPLAIN) 분석으로 인덱스 활용도와 효과를 꾸준히 점검합니다.

### 추가 학습 및 참고 자료

- **공식 문서**: 각 DBMS(MySQL, PostgreSQL, Oracle, MSSQL 등) 공식 자료
- **온·오프라인 강의**: 인덱스 구조를 시각적으로 이해할 수 있는 자료 추천
- **실무 예시**: GitHub, StackOverflow 등에서 인덱스 설계 사례를 참고