---
title: 멀티프로세스 vs 멀티쓰레드
date: 2025-01-11 00:00:00 +09:00
categories: [common_topic]
tags: [common]
image: 
---

# 들어가며

컴퓨터가 여러 작업을 동시에 처리하기 위해서는 크게 **멀티프로세스(Multi-Process)**와 **멀티쓰레드(Multi-Thread)** 두 가지 접근 방식이 있습니다.

작업을 “프로세스 단위”로 나누어 실행할 것인지, “프로세스 내부의 여러 스레드”로 분할할 것인지에 따라 시스템 구조와 성능, 안정성이 크게 달라집니다.

이번 글에서는 멀티프로세스와 멀티쓰레드가 각각 무엇이며, 어떤 특징과 장단점을 갖는지 살펴봅니다. 또한, 작업 성격(예: CPU 바운드, I/O 바운드)에 따라 어떤 방식이 더 유리한지도 구체적으로 알아봅니다.

---

# 1. 멀티프로세스(Multi-Process)

## 1.1 멀티프로세스란?

> "A process is an instance of a program in execution. In a multi-process system, multiple such instances run independently, enabling parallel execution of tasks."

이 정의에서 볼 수 있듯이, 프로세스(Process)는 실행 중인 프로그램의 인스턴스를 의미합니다.

**멀티프로세스** 환경에서는 한 시스템에서 여러 프로세스가 서로 독립적으로 실행되며, CPU가 여러 코어를 가진 경우 병렬적인 처리도 가능합니다.

### 예시

- **웹 브라우저**에서 탭마다 별도의 프로세스를 실행하는 방식.
  - 한 탭이 문제가 생겨도 다른 탭에는 영향을 주지 않는 안정성이 확보됩니다.

---

## 1.2 멀티프로세스의 특징

1. **프로세스 간 독립성**

   > "Processes are isolated from each other in terms of memory and resources. This ensures that an issue in one process does not affect the others."

   - 각 프로세스는 독립된 메모리 공간(Code, Data, Heap, Stack)을 가지고, 운영체제가 별도의 자원을 할당합니다.
   - 한 프로세스에 오류가 생겨도 다른 프로세스에 직접적인 영향을 주지 않아, 안정성과 보안 측면에서 유리합니다.

2. **자원 격리**
   - 파일 핸들, 네트워크 소켓 등 운영체제 자원이 프로세스마다 분리되어 할당됩니다.
   - 어떤 프로세스가 과도한 자원을 사용해도, 다른 프로세스에 미치는 영향이 제한적입니다.
3. **높은 안정성**
   - 프로세스가 서로 완전히 분리되어 있으므로, 하나가 충돌하더라도 시스템 전반의 안정성을 유지하기 쉽습니다.
   - 대규모 서버나 보안이 중요한 서비스에서 선호되는 구조입니다.

---

## 1.3 프로세스 간 통신(IPC, Inter-Process Communication)

프로세스가 서로 독립된 공간을 사용하는 만큼, 필요한 데이터를 주고받으려면 **IPC** 방식이 필요합니다.

1. **파이프(Pipe)**

   > "Pipes provide a simple communication mechanism by creating a unidirectional or bidirectional data channel between processes."

   - 부모-자식 프로세스 간 단방향(또는 양방향) 데이터 스트림을 구성해 통신합니다.
   - 구현이 비교적 간단하지만, 프로세스 관계나 전송 구조에 제약이 있을 수 있습니다.

2. **메시지 큐(Message Queue)**
   - 커널에서 관리하는 큐(Queue)에 메시지를 넣고, 다른 프로세스가 이를 꺼내서 처리합니다.
   - 여러 프로세스가 동시에 접근 가능하며, 메시지 기반 동기화가 가능합니다.
3. **공유 메모리(Shared Memory)**

   > "Shared memory enables processes to access common data efficiently, but it requires synchronization mechanisms to prevent race conditions."

   - 특정 메모리 영역을 여러 프로세스가 공유하여 고속 통신이 가능합니다.
   - 대신 동기화 문제(뮤텍스, 세마포어 등)를 반드시 고려해야 합니다.

4. **소켓(Sockets)**
   - 주로 네트워크 통신에 쓰이지만, 로컬 호스트 내 프로세스 간 통신에도 활용 가능합니다.
   - 유연성이 뛰어나지만, 상대적으로 구현이 복잡할 수 있습니다.

---

## 1.4 멀티프로세스의 장단점

### 장점

1. **안정성**
   - 한 프로세스가 충돌해도 다른 프로세스에는 직접 영향을 주지 않습니다.
   - 보안과 안전성이 중요한 시스템에서 선호됩니다.
2. **병렬 처리**
   - 멀티코어 환경에서 프로세스 단위로 병렬 실행이 가능해, **CPU 바운드** 작업에서 높은 성능을 낼 수 있습니다.
3. **보안성**
   - 메모리와 자원이 격리되어 있어, 프로세스 간 무단 접근이 어렵습니다.

### 단점

1. **높은 오버헤드**
   - 프로세스 생성과 컨텍스트 스위칭 비용이 큽니다.
   - IPC 통신 구현 및 유지도 복잡하고 추가 오버헤드가 발생합니다.
2. **통신 복잡성**
   - 공유 자원이 없으므로, 프로세스 간 협업에는 IPC를 사용해야 해 구현 난이도가 높습니다.
3. **메모리 사용량 증가**
   - 각 프로세스마다 독립된 메모리를 할당하므로, 전체 메모리 사용이 많아질 수 있습니다.

---

# 2. 멀티쓰레드(Multi-Thread)

## 2.1 멀티쓰레드란?

> "In computer architecture, multithreading is the ability of a central processing unit (CPU) (or a single core in a multi-core processor) to provide multiple threads of execution."

하나의 프로세스 내부에 여러 실행 흐름(스레드)을 만들고, 이 스레드들이 프로세스가 소유한 자원(코드, 데이터, 힙 등)을 공유하면서 독립적으로 실행되는 방식을 **멀티쓰레드**라고 합니다.

---

## 2.2 멀티쓰레드의 특징

1. **자원 공유**
   - 스레드는 같은 프로세스 공간 내에서 모든 자원을 공유하기 때문에, 스레드 간 데이터 전달이 매우 빠릅니다.
   - I/O 대기 시간이나 로직 분산 등에 유리합니다.
2. **독립적인 스택과 레지스터**
   - 스레드는 스택(Stack)과 레지스터 집합은 따로 가집니다.
   - 함수 호출, 지역 변수 관리 등은 스레드마다 독립적으로 이뤄집니다.
3. **동기화 문제**

   > "Race conditions occur when multiple threads simultaneously modify shared data, leading to unpredictable outcomes."

   - 여러 스레드가 동시에 공유 자원에 접근해 수정하면, 예상치 못한 경쟁 상태(Race Condition)가 발생할 수 있습니다.
   - 이를 방지하기 위해 뮤텍스(Mutex), 세마포어(Semaphore) 등의 동기화 메커니즘을 사용합니다.

---

## 2.3 동기화 기법 및 이슈

### 2.3.1 동기화 메커니즘

- **뮤텍스(Mutex)**
  > "Mutexes prevent multiple threads from simultaneously accessing shared data in a way that could cause conflicts."
  - 특정 자원(임계 구역)을 한 스레드만 점유하도록 잠금을 설정하고, 사용이 끝나면 잠금을 해제합니다.
- **세마포어(Semaphore)**
  - 동시 접근 가능한 스레드 수를 제한하는 기법으로, 주로 제한된 자원(예: 데이터베이스 커넥션 풀)에 적용됩니다.
- **락 프리(Lock-Free)** 자료구조
  - Compare-And-Swap(CAS) 같은 원자적 연산을 통해, 락 없이도 다중 스레드 환경에서 안전하게 동작하는 자료구조를 말합니다.

### 2.3.2 주요 동기화 이슈

- **데드락(Deadlock)**: 스레드들이 서로가 소유한 자원을 기다리며 교착 상태에 빠지는 상황.
- **기아(Starvation)**: 우선순위가 낮은 스레드가 자원을 계속 얻지 못해 실행 기회를 놓치는 문제.

---

## 2.4 멀티쓰레드의 장단점

### 장점

1. **자원 활용 효율**
   - 프로세스 자원을 공유하므로, 메모리 중복 할당이 줄고 스레드 간 통신도 간단·신속합니다.
2. **빠른 응답성과 컨텍스트 스위칭 비용**

   > "Multithreading can improve the responsiveness of applications by allowing multiple tasks to progress in parallel."

   - 스레드 간 전환은 프로세스 간 전환보다 가볍습니다.
   - GUI나 네트워크 서버처럼 실시간 응답이 필요한 애플리케이션에 특히 유용합니다.

3. **I/O 바운드 작업에 최적화**
   - I/O 대기 중 다른 스레드가 CPU를 사용하는 등 자원을 효율적으로 활용할 수 있습니다.

### 단점

1. **동기화 문제**
   - 공유 자원에 대한 접근을 올바르게 제어하지 않으면 경쟁 상태, 데드락 등이 발생해 오류가 생길 수 있습니다.
2. **오류 전이**
   - 한 스레드가 비정상 종료나 예외를 일으키면, 같은 프로세스 내 다른 스레드나 전체 프로세스에 영향을 미칩니다.
3. **디버깅 난이도**
   - 실행 흐름이 여러 개라 순서를 예측하기 어렵고, 동시성 버그가 발생하면 추적하기 매우 까다롭습니다.

---

# 3. 멀티프로세스 vs 멀티쓰레드 비교

| **항목**                 | **멀티프로세스 (Multi-Process)**                                               | **멀티쓰레드 (Multi-Thread)**                                                          |
| ------------------------ | ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------- |
| **자원 관리**            | 서로 다른 프로세스마다 독립된 메모리(Code, Data, Heap, Stack) 할당             | 프로세스 내 자원(코드, 데이터, 힙)을 공유하며, 스택과 레지스터는 스레드별로 독립       |
| **독립성 & 안정성**      | 한 프로세스 충돌이 다른 프로세스에 직접적 영향 없음, 보안·안정성 높음          | 한 스레드 오류 시 전체 프로세스에 영향 가능, 동기화 설계 미흡 시 안정성 떨어질 수 있음 |
| **통신 (데이터 교환)**   | 파이프, 메시지 큐, 공유 메모리, 소켓 등 IPC 필요 → 구현 난이도와 오버헤드 존재 | 프로세스 내부 자원 공유로 통신이 매우 빠르고 간단                                      |
| **컨텍스트 스위칭 비용** | 프로세스 생성·종료 및 스위칭 비용이 큼                                         | 스레드 스위칭은 비교적 저렴                                                            |
| **성능 특성**            | CPU 바운드 작업에 효과적, 병렬 처리를 통해 대규모 연산 가능                    | I/O 바운드 작업, 빠른 반응 요구 환경에 유리, 실시간 처리 가능                          |
| **메모리 사용량**        | 독립된 프로세스가 많아질수록 메모리 사용량 증가                                | 프로세스 자원을 공유하므로 메모리 사용량이 상대적으로 적음                             |
| **사용 사례**            | 서버 프로세스 분리, 대규모 병렬 계산, 보안이 필요한 시스템                     | 네트워크 서버 스레드, GUI 이벤트 처리, 실시간 데이터 스트리밍                          |

---

# 4. 사용 사례별 적합성

## 4.1 CPU 바운드 작업

- **정의**: 주로 복잡한 계산이나 대규모 연산이 중심이 되는 작업(과학·수학 연산, 머신러닝 모델 학습, 암호화 등).
- **멀티프로세스 선호**
  - 프로세스를 코어별로 분산해 병렬 계산할 수 있어, CPU 리소스를 최대한 활용 가능.
  - 프로세스 간 격리로 안전하며, Python 같은 GIL(Global Interpreter Lock) 이슈도 우회 가능.

## 4.2 I/O 바운드 작업

- **정의**: 디스크 입출력, 네트워크 통신, 대규모 파일 처리 등 I/O 연산이 병목이 되는 작업.
- **멀티쓰레드 선호**
  - I/O 대기 중 다른 스레드가 CPU를 사용할 수 있어, 자원 사용 효율과 응답성이 뛰어남.
  - 동시성이 중요한 웹 서버, 채팅 서비스, GUI 프로그램 등에서 큰 이점을 발휘합니다.

---

# 결론

멀티프로세스와 멀티쓰레드는 각각 **메모리 및 자원 관리 방식**, **독립성**, **성능 특성**이 다릅니다.

- **멀티프로세스**
  - 독립성과 안정성을 보장해야 하거나, 대규모 **CPU 바운드** 작업을 병렬로 분산하고자 할 때 유리합니다.
  - 보안이 중요한 시스템(서버, OS 모듈 등), 대규모 연산 처리, 프로세스 격리가 필요한 환경에서 자주 사용됩니다.
- **멀티쓰레드**
  - **I/O 바운드** 작업에서 스레드 간 빠른 통신과 자원 공유를 통해 높은 효율을 낼 수 있습니다.
  - 실시간 반응이 중요한 애플리케이션(네트워크 서버, GUI, 게임 엔진 등)에서 선호되며, 상대적으로 메모리를 적게 사용합니다.

결국, 어떤 방식을 택해야 할지는 **프로젝트 요구사항**(안정성, 보안, 성능 목표)과 **작업 특성**(CPU 바운드 vs I/O 바운드)에 따라 달라집니다.

또한, 멀티프로세스와 멀티쓰레드를 혼합해 사용하는 아키텍처(예: 각 프로세스에서 멀티쓰레드로 작업을 처리)도 많습니다.

가장 중요한 것은 **시스템 요구사항과 리소스 특성을 정확히 파악**한 뒤, 그에 맞는 구조를 설계·구현하는 것입니다.
