---
title: 정규화 vs 비정규화
date: 2025-02-08 00:13:00 +09:00
categories: [common_topic]
tags: [common]
image: /images/2025/2-8-Normalization.png
---

## 1. 정규화와 비정규화란 무엇인가?

### 1.1 정규화(Normalization)란?

- **정의**: 테이블 내의 **데이터 중복**과 **이상 현상(Anomaly)**을 최소화하기 위해 테이블을 작게 분할하고, 각 테이블 간에 적절한 관계(Relationship)를 설정하는 과정입니다.
- **목적**:
    1. **데이터 무결성(Integrity) 보장**
    2. **데이터 중복 최소화** (저장 공간 절약 및 업데이트 오류 방지)
    3. **이상 현상(갱신, 삭제, 삽입 이상)의 제거**
- **기본 정규형**:
    - 1정규형(1NF), 2정규형(2NF), 3정규형(3NF), BCNF(Boyce-Codd Normal Form) 등 단계별 규칙이 있으며, 상위 정규형을 만족하기 위해선 하위 정규형의 조건을 모두 만족해야 합니다.

### 1.2 비정규화(Denormalization)란?

- **정의**: **정규화된 스키마**를 일부러 깨트려서, 즉 **테이블을 합치거나 중복**을 일부 허용하여 **쿼리 성능** 혹은 **운영 편의성**을 높이는 설계 기법입니다.
- **목적**:
    1. **읽기(SELECT) 성능 최적화**
    2. **복잡한 JOIN 연산 감소**
    3. **빅데이터 환경에서 분산 처리 최적화** (샤딩, NoSQL 등과 연계)

---

## 2. 정규화의 원칙과 효과

### 2.1 정규화 단계별 특징

1. **1정규형(1NF)**:
    - **원자성(Atomicity)** 보장.
    - 컬럼이 더 이상 쪼개질 수 없는 원자 값(Scalar Value)으로 구성되어야 함.
2. **2정규형(2NF)**:
    - 부분 함수 종속(Partial Dependency) 제거.
    - 복합 키(Composite Key) 테이블에서, 키의 일부분만으로 종속되는 컬럼이 없어야 함.
3. **3정규형(3NF)**:
    - 이행적 종속(Transitive Dependency) 제거.
    - 기본 키가 아닌 컬럼을 통해 다른 컬럼이 종속되지 않아야 함.
4. **BCNF**:
    - 결정자(Determinant)가 모두 키(Key)인 상태.
    - 3NF에서 한 단계 더 엄격한 조건으로, 함수 종속성(Functional Dependency)을 엄격하게 관리.

### 2.2 정규화를 적용했을 때의 장점

- **데이터 무결성 보장**: 데이터 중복이 최소화되므로 갱신(UPDATE), 삭제(DELETE) 시 불일치가 발생할 가능성이 줄어듭니다.
- **저장 공간 효율성**: 중복 데이터가 줄어들어 테이블 용량이 감소하고, 관리 부담도 낮아집니다.
- **관리 용이성**: 특정 컬럼(속성)이 한 테이블에만 존재하므로 유지보수가 간단합니다.

### 2.3 정규화로 인한 단점 (혹은 제한 사항)

- **JOIN 증가**: 데이터가 여러 테이블에 나뉘어 저장되므로, 읽기 시에는 많은 JOIN이 발생할 수 있습니다.
- **복잡한 스키마**: 테이블이 여러 개로 쪼개지므로 설계가 복잡해지고, 직관성이 떨어질 수 있습니다.

---

## 3. 비정규화의 목적과 기법

### 3.1 비정규화를 적용하는 이유

- **쿼리 성능 개선**: 특정 조회 쿼리가 너무 많은 JOIN을 거쳐야 하는 경우, 테이블을 합치거나 일부 중복 컬럼을 두어 성능을 높일 수 있습니다.
- **빅데이터, OLAP 환경**: 대규모 데이터 분석(OLAP) 용도로, 중복을 허용하더라도 빠른 조회가 필요한 경우가 많습니다.
- **캐싱 및 분산 시스템**: 부분적으로 중복을 허용해 여러 노드에 데이터를 복제(Replication)함으로써 조회 성능을 향상시킬 수 있습니다.

### 3.2 비정규화 기법 예시

1. **테이블 통합**
    - 지나치게 세분화된 테이블을 하나로 합쳐 JOIN 없이 직접 데이터에 접근하도록 합니다.
    - 예) 사용자 정보 테이블과 프로필 테이블을 통합
2. **중복 컬럼 추가**
    - 자주 사용하는 조인 대상 컬럼을 원본 테이블에도 추가 저장합니다.
    - 예) `order` 테이블에 사용자 이름, 주소 등을 중복 저장
3. **예측 컬럼(Computed Column) 추가**
    - 자주 필요한 계산 결과(예: 합계, 평균)를 미리 칼럼으로 저장해둬 쿼리 시 계산 부담을 줄임.
4. **파티셔닝(Partitioning) & 샤딩(Sharding)**
    - 물리적으로 데이터 분할. 정규화와는 별개로 고려되지만, 대규모 분산 환경에서 비정규화와 함께 활용되기도 함.

### 3.3 비정규화의 장단점

### 장점

- **읽기(SELECT) 성능 향상**: JOIN이 줄어드므로 응답 시간이 짧아집니다.
- **단순한 조회 로직**: 일부 중복된 데이터가 있더라도, 필요한 정보를 한 테이블에서 빠르게 조회할 수 있습니다.

### 단점

- **데이터 불일치 위험 증가**: 중복이 생기면, 갱신 시 여러 위치의 데이터를 모두 수정해야 합니다.
- **저장 공간 증가**: 테이블을 통합하거나, 컬럼을 중복 저장하면서 디스크 사용량이 늘어날 수 있습니다.

---

## 4. 정규화 vs 비정규화: 적용 시 고려 사항

1. **시스템 종류(OLTP vs OLAP)**
    - **OLTP**(Online Transaction Processing): 은행, 쇼핑몰 등의 트랜잭션 중심 서비스에서는 데이터 무결성과 일관성이 매우 중요하므로, 정규화가 선호됩니다.
    - **OLAP**(Online Analytical Processing): 대규모 데이터 분석 목적(데이터 웨어하우스 등) 시스템에서는 조회 성능이 더 중요하므로, 비정규화를 활용하기도 합니다.
2. **데이터 규모 & 성능 요구 사항**
    - 데이터가 매우 방대하고 읽기 성능이 우선인 경우, 비정규화로 인한 중복 관리 비용이 감수할 만한 수준인지 판단해야 합니다.
    - 업데이트가 빈번하다면, 비정규화로 인해 갱신 작업이 복잡해지므로 신중해야 합니다.
3. **쿼리 패턴 분석**
    - 정규화된 모델에서 JOIN 횟수가 많아 쿼리 시간이 비효율적으로 길어지는지 확인합니다.
    - 특정 컬럼에 대한 조회나 집계가 특히 잦다면, 중복 칼럼(혹은 물리적 통합)을 고려해볼 수 있습니다.
4. **개발 & 운영 팀 역량**
    - 정규화된 구조는 이론적으로 장점이 많지만, 실제 업무에서는 JOIN이 과다하게 발생할 수 있습니다.
    - 비정규화를 적용하려면, 중복 데이터 관리를 위한 어플리케이션 레벨 로직과 운영 정책이 필요합니다.

---

## 5. 사례별 접근 전략

1. **중소 규모 웹 서비스(OLTP 기반)**
    - 회원, 게시글, 댓글 등 트랜잭션이 많고, DB에서 빠른 업데이트와 정확한 무결성이 필요함.
    - 주로 **3정규형** 정도까지 정규화 적용 후, 성능 병목 구간이 확인되는 경우에만 부분 비정규화 고려.
2. **대규모 데이터 분석(OLAP 기반)**
    - 주로 SELECT가 많고, 집계(Aggregation) 연산이 잦으며, JOIN이 많아질 수밖에 없음.
    - 초기 설계 시부터 차원 테이블(Fact, Dimension) 구조를 갖춘 스타 스키마(Star Schema)나 스노우플레이크 스키마(Snowflake Schema) 등으로 **부분적 비정규화**를 적용.
3. **하이브(분산 파일 시스템), NoSQL 등**
    - RDBMS와 달리 JOIN 기능이 제한적이거나, 직접 MapReduce 작업으로 JOIN을 구현해야 할 수도 있음.
    - **데이터 중복**을 일부 허용하여 읽기 성능을 극대화하고, 고가용성(High Availability)을 확보하기도 함.

---

## 6. 모범 사례 및 실무 팁

1. **단계별 정규화 후 ‘필요시’ 비정규화**
    - 처음부터 비정규화를 고려하기보다는, 우선 정규화된 모델을 만든 뒤, 쿼리 프로파일링(실행 계획 분석) 결과 병목이 확인되는 부분만 비정규화합니다.
2. **변경 시점 정의**
    - 비정규화된 컬럼을 언제, 어떤 트랜잭션에서 갱신할지 명확히 해야 합니다. (예: 주문 테이블에 있는 고객명을 수정할 경우, 고객 정보가 변경될 때마다 동기화해야 함)
3. **아키텍처적 접근**
    - 인덱스를 활용하거나 캐싱 레이어(Redis 등)를 추가해 성능을 높일 수 있는 방법이 있는지 먼저 살펴보세요. 비정규화는 데이터베이스 내부 구조를 바꾸는 큰 결정이므로 신중해야 합니다.
4. **문서화 및 주기적 점검**
    - 비정규화된 테이블이나 중복 컬럼은 반드시 문서화하여 팀원들이 인지하도록 합니다.
    - 데이터 불일치가 발생하지 않는지, 주기적으로 모니터링하는 프로세스를 갖추세요.

---

## 7. 결론

**정규화 vs 비정규화**는 항상 트레이드오프(Trade-off)가 존재합니다.

- **정규화**는 데이터 무결성과 중복 관리 측면에서 뛰어나며, 유지보수가 용이하지만, 읽기 성능(특히 JOIN이 많을 때)이 저하될 수 있습니다.
- **비정규화**는 읽기 성능을 극적으로 향상시킬 수 있지만, 중복 데이터 관리, 업데이트 시 데이터 일관성 유지에 대한 부담이 늘어납니다.

**궁극적으로는**, 시스템의 목적(OLTP, OLAP, 빅데이터 분석, 트랜잭션 처리, 분산환경 등)과 **쿼리 패턴, 데이터 특성, 팀 역량**을 종합적으로 고려해 **적절한 균형점**을 찾는 것이 중요합니다.

처음엔 정규화를 충분히 적용한 후, **성능 분석**을 통해 병목 지점에서 최소한의 비정규화만 점진적으로 진행하는 접근이 일반적입니다.

> “정규화가 데이터베이스 설계의 기초라면, 비정규화는 고도의 성능 최적화를 위한 선택”
> 

최적의 설계를 찾기 위해선 정규화와 비정규화, 두 가지 모두의 장단점을 정확히 파악하고, 실제 운영 환경을 철저히 분석하는 노력이 필요합니다.