---
title: 정규화 vs 비정규화
date: 2025-02-08 00:13:00 +09:00
categories: [common_topic]
tags: [common]
image: /images/2025/2-8-Normalization.png
---
![image.png](/images/2025/2-8-Normalization.png)

데이터베이스를 설계할 때, **중복을 최소화하면서도 성능을 최적화하는 방법**을 고민해본 적이 있을 것입니다. 이를 해결하는 대표적인 기법이 **정규화(Normalization)**로, 데이터의 무결성을 유지하고 이상 현상을 방지하기 위해 테이블을 구조화하는 과정입니다. 하지만 지나친 정규화는 **JOIN 증가로 성능이 저하될 수 있어**, 일부러 중복을 허용하는 **비정규화(Denormalization)**를 적용하기도 합니다.

따라서, **정규화와 비정규화는 서로 대립하는 개념이 아니라, 데이터베이스 설계에서 균형을 맞춰야 하는 두 가지 접근 방식**입니다. 이 글에서는 **정규화와 비정규화의 개념과 차이점, 그리고 언제 어떤 방식을 선택해야 하는지**를 알아보겠습니다. 🚀

## 1. 정규화와 비정규화란 무엇인가?

### 1.1 정규화(Normalization)란?

- **정의**: 테이블 내의 **데이터 중복**과 **이상 현상(Anomaly)**을 최소화하기 위해 테이블을 작게 분할하고, 각 테이블 간에 적절한 관계(Relationship)를 설정하는 과정입니다.
- **목적**:
    1. **데이터 무결성(Integrity) 보장**
    2. **데이터 중복 최소화** (저장 공간 절약 및 업데이트 오류 방지)
    3. **이상 현상(갱신, 삭제, 삽입 이상)의 제거**
- **기본 정규형**:
    - 1정규형(1NF), 2정규형(2NF), 3정규형(3NF), BCNF(Boyce-Codd Normal Form) 등 단계별 규칙이 있으며, 상위 정규형을 만족하기 위해선 하위 정규형의 조건을 모두 만족해야 합니다.

### 1.2 비정규화(Denormalization)란?

- **정의**: **정규화된 스키마**를 일부러 깨트려서, 즉 **테이블을 합치거나 중복**을 일부 허용하여 **쿼리 성능** 혹은 **운영 편의성**을 높이는 설계 기법입니다.
- **목적**:
    1. **읽기(SELECT) 성능 최적화**
    2. **복잡한 JOIN 연산 감소**
    3. **빅데이터 환경에서 분산 처리 최적화** (샤딩, NoSQL 등과 연계)

---

## **2. 정규화의 원칙과 효과**

### **2.1 정규화 단계별 특징**

1. **1정규형(1NF) - 원자성(Atomicity) 보장**
    - 컬럼이 **더 이상 나눌 수 없는 원자 값(Scalar Value)으로 구성**되어야 함.
    - **중첩된 데이터(배열, 리스트, 중복 필드 등)를 허용하지 않음.**
2. **2정규형(2NF) - 부분 함수 종속(Partial Dependency) 제거**
    - **기본 키(Primary Key)의 일부에만 종속된 컬럼을 제거.**
    - 즉, **복합 키(Composite Key)를 사용하는 경우, 모든 비키 컬럼이 기본 키 전체에 종속되어야 함.**
3. **3정규형(3NF) - 이행적 종속(Transitive Dependency) 제거**
    - 기본 키가 아닌 컬럼이 **다른 비키 컬럼을 결정하지 않아야 함.**
    - 즉, **모든 비키 컬럼은 기본 키에만 직접 종속되어야 함.**
4. **BCNF(Boyce-Codd Normal Form) - 결정자(Determinant) 강화**
    - 3NF보다 더 강력한 정규형으로, **모든 결정자가 후보 키(Candidate Key)이어야 함.**
    - 즉, 테이블에서 **키(Key)가 아닌 컬럼이 다른 컬럼을 결정하는 경우를 제거**해야 함.
5. **4정규형(4NF) - 다치 종속(Multi-Valued Dependency) 제거**
    - 한 테이블에서 **한 키가 여러 개의 독립적인 다치 종속 값을 가질 경우 분리**해야 함.
    - 즉, **한 개의 키에 대해 여러 개의 독립적인 속성이 존재하는 경우, 이를 별도 테이블로 분리하여 정규화.**
6. **5정규형(5NF) - 조인 종속(Join Dependency) 제거**
    - **모든 조인이 손실 없이 재구성될 수 있도록 분해**해야 함.
    - 특정 테이블이 **하위 테이블들로 분리될 때, 원래 관계를 유지할 수 있어야 한다는 원칙.**
    - 일반적으로 **데이터 모델이 지나치게 복잡해질 경우, 5NF까지 적용할 일은 드뭄.**

---

### **2.2 정규화를 적용했을 때의 장점**

✅ **데이터 무결성 보장**

- 데이터 중복을 최소화하여 **갱신(UPDATE)이나 삭제(DELETE) 시 불일치 문제를 방지**.

✅ **저장 공간 효율성 향상**

- 불필요한 데이터 중복이 사라지면서 **테이블 크기가 감소**하여 저장 공간 절약.

✅ **관리 용이성 증가**

- 데이터가 여러 테이블에 정리되므로, **한 곳에서만 수정하면 일관성을 유지할 수 있음**.

✅ **이상 현상(Anomaly) 방지**

- **삽입 이상(Insert Anomaly), 갱신 이상(Update Anomaly), 삭제 이상(Delete Anomaly)을 제거**하여 데이터 안정성 향상.

---

### **2.3 정규화의 단점 (혹은 제한 사항)**

⚠️ **JOIN 연산 증가**

- **데이터가 여러 테이블로 분리**되므로, 조회 시 **JOIN 연산이 많이 발생하여 성능 저하 가능**.

⚠️ **설계 및 유지보수 복잡도 증가**

- 테이블이 많아질수록 **데이터 모델이 복잡해지고, SQL 쿼리가 길어질 수 있음**.

⚠️ **실제 운영 환경에서 성능 저하 가능성**

- 트랜잭션이 많거나 실시간 처리가 중요한 경우, 지나친 정규화는 **오히려 성능을 저하시킬 수 있음**.
- 이런 경우, **비정규화(Denormalization)를 활용하여 성능 최적화 필요**.

---

## 3. 비정규화의 목적과 기법

### 3.1 비정규화를 적용하는 이유

- **쿼리 성능 개선**: 특정 조회 쿼리가 너무 많은 JOIN을 거쳐야 하는 경우, 테이블을 합치거나 일부 중복 컬럼을 두어 성능을 높일 수 있습니다.
- **빅데이터, OLAP 환경**: 대규모 데이터 분석(OLAP) 용도로, 중복을 허용하더라도 빠른 조회가 필요한 경우가 많습니다.
- **캐싱 및 분산 시스템**: 부분적으로 중복을 허용해 여러 노드에 데이터를 복제(Replication)함으로써 조회 성능을 향상시킬 수 있습니다.

### 3.2 비정규화 기법 예시

1. **테이블 통합**
    - 지나치게 세분화된 테이블을 하나로 합쳐 JOIN 없이 직접 데이터에 접근하도록 합니다.
    - 예) 사용자 정보 테이블과 프로필 테이블을 통합
2. **중복 컬럼 추가**
    - 자주 사용하는 조인 대상 컬럼을 원본 테이블에도 추가 저장합니다.
    - 예) `order` 테이블에 사용자 이름, 주소 등을 중복 저장
3. **예측 컬럼(Computed Column) 추가**
    - 자주 필요한 계산 결과(예: 합계, 평균)를 미리 칼럼으로 저장해둬 쿼리 시 계산 부담을 줄임.
4. **파티셔닝(Partitioning) & 샤딩(Sharding)**
    - 물리적으로 데이터 분할. 정규화와는 별개로 고려되지만, 대규모 분산 환경에서 비정규화와 함께 활용되기도 함.

### 3.3 비정규화의 장단점

### 장점

- **읽기(SELECT) 성능 향상**: JOIN이 줄어드므로 응답 시간이 짧아집니다.
- **단순한 조회 로직**: 일부 중복된 데이터가 있더라도, 필요한 정보를 한 테이블에서 빠르게 조회할 수 있습니다.

### 단점

- **데이터 불일치 위험 증가**: 중복이 생기면, 갱신 시 여러 위치의 데이터를 모두 수정해야 합니다.
- **저장 공간 증가**: 테이블을 통합하거나, 컬럼을 중복 저장하면서 디스크 사용량이 늘어날 수 있습니다.

---

## 4. 정규화 vs 비정규화: 적용 시 고려 사항

1. **시스템 종류(OLTP vs OLAP)**
    - **OLTP**(Online Transaction Processing): 은행, 쇼핑몰 등의 트랜잭션 중심 서비스에서는 데이터 무결성과 일관성이 매우 중요하므로, 정규화가 선호됩니다.
    - **OLAP**(Online Analytical Processing): 대규모 데이터 분석 목적(데이터 웨어하우스 등) 시스템에서는 조회 성능이 더 중요하므로, 비정규화를 활용하기도 합니다.
2. **데이터 규모 & 성능 요구 사항**
    - 데이터가 매우 방대하고 읽기 성능이 우선인 경우, 비정규화로 인한 중복 관리 비용이 감수할 만한 수준인지 판단해야 합니다.
    - 업데이트가 빈번하다면, 비정규화로 인해 갱신 작업이 복잡해지므로 신중해야 합니다.
3. **쿼리 패턴 분석**
    - 정규화된 모델에서 JOIN 횟수가 많아 쿼리 시간이 비효율적으로 길어지는지 확인합니다.
    - 특정 컬럼에 대한 조회나 집계가 특히 잦다면, 중복 칼럼(혹은 물리적 통합)을 고려해볼 수 있습니다.
4. **개발 & 운영 팀 역량**
    - 정규화된 구조는 이론적으로 장점이 많지만, 실제 업무에서는 JOIN이 과다하게 발생할 수 있습니다.
    - 비정규화를 적용하려면, 중복 데이터 관리를 위한 어플리케이션 레벨 로직과 운영 정책이 필요합니다.

---

## 5. 사례별 접근 전략

1. **중소 규모 웹 서비스(OLTP 기반)**
    - 회원, 게시글, 댓글 등 트랜잭션이 많고, DB에서 빠른 업데이트와 정확한 무결성이 필요함.
    - 주로 **3정규형** 정도까지 정규화 적용 후, 성능 병목 구간이 확인되는 경우에만 부분 비정규화 고려.
2. **대규모 데이터 분석(OLAP 기반)**
    - 주로 SELECT가 많고, 집계(Aggregation) 연산이 잦으며, JOIN이 많아질 수밖에 없음.
    - 초기 설계 시부터 차원 테이블(Fact, Dimension) 구조를 갖춘 스타 스키마(Star Schema)나 스노우플레이크 스키마(Snowflake Schema) 등으로 **부분적 비정규화**를 적용.
3. **하이브(분산 파일 시스템), NoSQL 등**
    - RDBMS와 달리 JOIN 기능이 제한적이거나, 직접 MapReduce 작업으로 JOIN을 구현해야 할 수도 있음.
    - **데이터 중복**을 일부 허용하여 읽기 성능을 극대화하고, 고가용성(High Availability)을 확보하기도 함.

---

## 6. 모범 사례 및 실무 팁

1. **단계별 정규화 후 ‘필요시’ 비정규화**
    - 처음부터 비정규화를 고려하기보다는, 우선 정규화된 모델을 만든 뒤, 쿼리 프로파일링(실행 계획 분석) 결과 병목이 확인되는 부분만 비정규화합니다.
2. **변경 시점 정의**
    - 비정규화된 컬럼을 언제, 어떤 트랜잭션에서 갱신할지 명확히 해야 합니다. (예: 주문 테이블에 있는 고객명을 수정할 경우, 고객 정보가 변경될 때마다 동기화해야 함)
3. **아키텍처적 접근**
    - 인덱스를 활용하거나 캐싱 레이어(Redis 등)를 추가해 성능을 높일 수 있는 방법이 있는지 먼저 살펴보세요. 비정규화는 데이터베이스 내부 구조를 바꾸는 큰 결정이므로 신중해야 합니다.
4. **문서화 및 주기적 점검**
    - 비정규화된 테이블이나 중복 컬럼은 반드시 문서화하여 팀원들이 인지하도록 합니다.
    - 데이터 불일치가 발생하지 않는지, 주기적으로 모니터링하는 프로세스를 갖추세요.

---

## 7. 결론

**정규화 vs 비정규화**는 항상 트레이드오프(Trade-off)가 존재합니다.

- **정규화**는 데이터 무결성과 중복 관리 측면에서 뛰어나며, 유지보수가 용이하지만, 읽기 성능(특히 JOIN이 많을 때)이 저하될 수 있습니다.
- **비정규화**는 읽기 성능을 극적으로 향상시킬 수 있지만, 중복 데이터 관리, 업데이트 시 데이터 일관성 유지에 대한 부담이 늘어납니다.

**궁극적으로는**, 시스템의 목적(OLTP, OLAP, 빅데이터 분석, 트랜잭션 처리, 분산환경 등)과 **쿼리 패턴, 데이터 특성, 팀 역량**을 종합적으로 고려해 **적절한 균형점**을 찾는 것이 중요합니다.

처음엔 정규화를 충분히 적용한 후, **성능 분석**을 통해 병목 지점에서 최소한의 비정규화만 점진적으로 진행하는 접근이 일반적입니다.

> “정규화가 데이터베이스 설계의 기초라면, 비정규화는 고도의 성능 최적화를 위한 선택”
> 

최적의 설계를 찾기 위해선 정규화와 비정규화, 두 가지 모두의 장단점을 정확히 파악하고, 실제 운영 환경을 철저히 분석하는 노력이 필요합니다.