---
title: 동기/비동기, 블로킹/논블로킹
date: 2025-01-18 00:13:00 +09:00
categories: [common_topic]
tags: [common]
image: 
---

# 들어가며: 동기/비동기, 블로킹/논블로킹의 중요성

서버나 애플리케이션을 설계·개발할 때, 가장 중요한 것 중 하나가 **효율적인 자원 활용**과 **응답성**입니다.

- “**동기/비동기**”는 “작업을 어떻게 **순서**(또는 시간) 관점에서” 처리할 것인지,
- “**블로킹/논블로킹**”은 “작업을 요청했을 때, **제어 흐름**(쓰레드)이 멈추느냐 혹은 계속 움직이느냐”를 결정하는 핵심 키워드입니다.

단어 자체는 비슷하게 보일 수 있지만, 이 두 쌍은 서로 다른 차원의 개념이며 각기 다른 문제를 해결합니다. 이를 제대로 구분하고 설계에 반영하면, 시스템 성능과 유지보수성을 큰 폭으로 향상할 수 있습니다.

---

# 1. 동기(Synchronous)와 비동기(Asynchronous)의 개념

## 1.1 동기의 정의 및 특징

- **정의**
  - \*동기(Synchronous)**란, 호출자(작업 요청 주체)와 피호출자(작업 수행 주체)가 “**시간적으로 서로 맞물려\*\*” 움직이는 방식입니다.
  - 호출자가 작업을 요청하면, 피호출자가 그 작업을 끝낼 때까지 **호출자는 계속 대기**해야 하고, 결과가 나온 후에야 다음 작업을 진행합니다.
- **특징**
  1. **단순성**: 순차적으로 작업이 진행되어 흐름을 파악하기 쉽습니다.
  2. **직관성**: 결과를 기다렸다가 바로 사용하는 로직을 짜기 편합니다.
  3. **잠재적 지연**: 한 작업이 오래 걸리면, 그 뒤에 대기하는 작업이 전부 지연될 수 있습니다.
- **활용 사례**
  - **파일 읽기/쓰기**에서 간단한 스크립트 처리(작업량이 적고 요청이 많지 않을 때).
  - **동기 메서드 호출**: 예) Java에서 `someFunction()` 호출 후 결과를 바로 받아 사용.

## 1.2 비동기의 정의 및 특징

- **정의**
  - \*비동기(Asynchronous)**는 “**호출자가 요청을 보낸 후, 결과를 기다리며 멈추지 않고\*\*” 다른 작업을 할 수 있는 방식입니다.
  - 피호출자는 작업이 끝나면 **콜백(Callback)**, **이벤트(Event)**, **프로미스(Promise/Future)** 등을 통해 **나중에 결과를 알려줍니다**.
- **특징**
  1. **높은 효율**: 긴 작업을 요청해놓고, 그 사이에 다른 일을 처리할 수 있습니다.
  2. **복잡한 제어 흐름**: 결과가 언제 도착할지 모른다는 점에서 로직이 복잡해질 수 있습니다(콜백 지옥, 비동기 흐름 관리 등).
  3. **병렬 처리 효과**: 실제로 멀티쓰레드/멀티코어에서 작업을 병렬 실행하지 않더라도, I/O 대기를 효율적으로 숨길 수 있습니다.
- **활용 사례**
  - **네트워크 요청**: HTTP 요청 후 응답을 기다리는 동안, 다른 요청을 병렬로 처리하는 웹 서버.
  - **UI 이벤트 처리**: GUI 프로그램에서 비동기로 API 호출을 하고, 호출이 끝나면 화면 업데이트.

## 1.3 동기 vs 비동기: 비교 요약

| 구분          | 동기(Synchronous)                             | 비동기(Asynchronous)                                         |
| ------------- | --------------------------------------------- | ------------------------------------------------------------ |
| **흐름 제어** | 호출자가 작업 완료까지 기다림                 | 호출자가 기다리지 않고 다른 작업 수행 가능                   |
| **장점**      | 로직이 단순, 직관적                           | 자원 효율 극대화, I/O 대기 최소화, 병렬성 향상               |
| **단점**      | 장시간 대기로 인해 전체 처리량 낮아질 수 있음 | 로직이 복잡해질 수 있고, 디버깅·콜백 지옥 등 유지보수 어려움 |
| **사용 예**   | 파일 I/O, 작은 작업 순차 처리                 | 대규모 웹 서버, UI 이벤트, 네트워크 API 호출 등              |

---

# 2. 블로킹(Blocking)과 논블로킹(Non-blocking)의 개념

## 2.1 블로킹의 정의 및 특징

- **정의**
  - \*블로킹(Blocking)**은 어떤 함수(또는 호출)가 호출자의 쓰레드를 **멈추게\*\*(block) 만드는 방식입니다.
  - 예) `read()` 함수를 호출했는데, 읽을 데이터가 준비되지 않았다면 함수를 호출한 쓰레드는 **해당 `read()`가 끝날 때까지 대기**해야 합니다.
- **특징**
  1. **직관적인 코드**: “함수 호출 → 완료 시점에 제어가 반환”이므로 제어 흐름이 간단합니다.
  2. **자원 비효율**: I/O 대기가 길어지면, 해당 쓰레드는 아무것도 못하고 멈춘 채 자원을 차지합니다.
  3. **쓰레드 풀 고려 필요**: 다중 요청을 처리하려면 쓰레드를 많이 만들어야 하고, 이는 스레드 컨텍스트 스위칭 비용을 유발합니다.
- **활용 사례**
  - **간단한 CLI 프로그램**에서 입력을 블로킹 방식으로 받음.
  - **동기 블로킹** 방식 API: POSIX의 전통적 I/O 함수(`fread`, `fwrite` 등).

## 2.2 논블로킹의 정의 및 특징

- **정의**
  - \*논블로킹(Non-blocking)**은 함수를 호출했을 때, **바로 반환**되어 호출자의 쓰레드는 **멈추지 않고\*\* 계속 진행할 수 있는 방식입니다.
  - 예) `read()` 호출 시에, 만약 읽을 데이터가 준비되지 않았다면 즉시 “준비되지 않음”이라는 상태값을 반환하고 돌아옵니다.
- **특징**
  1. **쓰레드 효율**: I/O가 준비되지 않았을 때도 쓰레드가 계속 다른 일을 할 수 있어, 시스템 자원을 더 효율적으로 사용합니다.
  2. **복잡성 증가**: 반환 상태에 따라 작업 흐름을 나눠야 하고, 자료가 준비되지 않으면 재시도 로직을 작성해야 합니다.
  3. **주기적 폴링(Polling)**: 논블로킹 API를 계속 호출하며 “데이터 준비 여부”를 확인하는 식으로 구현하면, CPU 오버헤드가 생길 수도 있습니다.
- **활용 사례**
  - **고성능 네트워크 서버**(예: epoll, kqueue, select/poll 등을 활용).
  - **GUI 이벤트 루프**에서 논블로킹으로 사용자 입력 등을 체크.

## 2.3 블로킹 vs 논블로킹: 비교 요약

| 구분          | 블로킹(Blocking)                                   | 논블로킹(Non-blocking)                                |
| ------------- | -------------------------------------------------- | ----------------------------------------------------- |
| **흐름 제어** | 함수 호출 시 작업이 끝날 때까지 쓰레드가 대기      | 함수 호출 시 즉시 반환, 쓰레드가 멈추지 않음          |
| **장점**      | 로직이 단순, 직관적인 프로그래밍                   | 쓰레드 활용 극대화, I/O 대기 시간 동안 다른 작업 가능 |
| **단점**      | 대기 시간 동안 쓰레드가 아무것도 못 함 → 자원 낭비 | 폴링, 상태 체크 로직 등 구현이 복잡해질 수 있음       |
| **사용 예**   | 간단한 입출력, POSIX 전통 I/O 함수                 | 고성능 네트워크 서버, GUI 이벤트 루프, epoll/kqueue   |

---

# 3. 동기/비동기와 블로킹/논블로킹의 조합

이제 “동기 vs 비동기”와 “블로킹 vs 논블로킹”을 **서로 독립된 개념**으로 이해하고, 네 가지 조합을 정리해볼 수 있습니다.

1. **동기 + 블로킹**
   - **가장 전통적인 방식**
   - 함수가 호출자를 즉시 멈추게 하고, 결과가 나올 때까지 기다림
   - 예) “파일 읽기 함수”가 작업 완료 후 제어를 반환
2. **동기 + 논블로킹**
   - 함수는 즉시 반환하지만, 호출자가 “결과가 준비될 때까지” 직접 확인(폴링)하거나, 작업이 끝날 때까지 사실상 반복 호출
   - 완전히 “비동기”라고는 할 수 없고, “동기 논블로킹 호출”을 주기적으로 하는 형태
   - 예) `select()`를 통해 파일 상태를 체크하되, 데이터가 없으면 다시 시도
3. **비동기 + 블로킹**
   - 함수 호출 직후에는 제어가 돌아오지만, 결과 처리를 기다리는 단계에서 호출자가 블로킹될 수도 있음
   - 예) `future.get()`을 호출했을 때, 비동기로 실행 중인 작업이 끝나지 않았다면 `get()` 호출한 쓰레드가 블로킹됨
4. **비동기 + 논블로킹**
   - **가장 고도화된 방식**
   - 요청과 동시에 호출자는 즉시 제어를 얻으며, 결과는 “콜백이나 이벤트”로 전달
   - I/O 작업도 논블로킹 방식으로 수행되므로, 시스템 자원을 매우 효율적으로 사용 가능
   - 예) Node.js의 이벤트 루프, epoll 기반의 웹 서버

## 3.1 각 조합의 장단점

| 조합                  | 장점                                                                         | 단점                                                                      |
| --------------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **동기 + 블로킹**     | 구현이 매우 직관적, 이해하기 쉬움                                            | 대기시간이 길면 시스템 전반에 영향, 쓰레드 낭비 발생                      |
| **동기 + 논블로킹**   | 호출이 즉시 반환되어 잠시 다른 일을 할 수 있음                               | 결과를 얻는 시점이 불투명 → 지속적으로 재시도(폴링)해야 해 복잡도 증가    |
| **비동기 + 블로킹**   | 결과 알림(비동기)과 실제 결과 기다림(블로킹)이 혼합되어 **병렬성** 활용 가능 | 최종 결과를 가져오는 순간에 쓰레드가 다시 블로킹됨 → 완전히 논블로킹 아님 |
| **비동기 + 논블로킹** | 병렬성 극대화, I/O 대기 시간이 거의 숨겨짐 → 고성능 시스템 구현 가능         | 제어 흐름이 복잡해지고, 콜백·이벤트 기반 설계 필요. 디버깅 난이도 상승    |

---

# 4. 실제 사례 분석

## 4.1 네트워크 요청 처리

- **블로킹 소켓 API vs 논블로킹 소켓 API**
  - 블로킹 소켓은 `accept()`, `recv()` 등에서 데이터가 준비될 때까지 쓰레드를 멈춤.
  - 논블로킹 소켓은 준비되지 않으면 에러나 특별 상태값을 즉시 반환하고, epoll/kqueue/select/poll 등을 통해 이벤트 기반으로 처리.
- **동기 vs 비동기 서버 구조**
  - **동기 블로킹** 서버: 요청이 끝날 때까지 쓰레드 하나가 전담(전통적인 Apache 방식).
  - **비동기 논블로킹** 서버: 이벤트 루프가 I/O 이벤트를 처리(Nginx, Node.js 등).

## 4.2 데이터베이스 I/O 처리

- **JDBC 동기 블로킹**
  - SQL 쿼리 실행 시, 결과가 나올 때까지 해당 쓰레드가 기다림.
  - 트랜잭션 처리, 커넥션 풀 관리에 익숙해 유지보수가 쉽지만, 대규모 동시 요청에서는 쓰레드 수가 폭증할 수 있음.
- **비동기 DB 드라이버**
  - Redis나 MongoDB 등에서 지원하는 비동기 드라이버는 요청 후 콜백으로 응답을 처리.
  - 대기 시간 중 쓰레드가 계속 다른 일을 할 수 있어, 자원 효율이 높음.

---

# 5. 동기/비동기와 블로킹/논블로킹 선택 시 고려 사항

1. **작업 특성**
   - CPU 바운드 vs I/O 바운드, 요청 횟수와 응답 지연 시간, 시스템 규모 등에 따라 다른 방식을 적용해야 합니다.
2. **개발 난이도 및 유지보수**
   - 비동기·논블로킹 모델은 성능은 좋지만, 코드 흐름이 복잡해지므로 디버깅과 테스트가 어렵습니다.
   - 작은 규모에서는 단순한 동기 블로킹 모델이 오히려 유지보수에 유리할 수 있습니다.
3. **프레임워크·언어 지원**
   - Node.js처럼 기본적으로 비동기 이벤트 루프를 제공하는 환경도 있고, Java의 NIO처럼 논블로킹 I/O를 지원하는 라이브러리도 있습니다.
   - 언어나 런타임의 특성에 따라 설계 방식을 결정해야 합니다.
4. **병행 처리 수준**
   - 멀티쓰레드 vs 이벤트 기반 모델 vs 멀티프로세스 중 어떤 병행 패턴을 사용할지, 그리고 동기·비동기/블로킹·논블로킹의 조합은 어떻게 할지가 핵심입니다.

---

# 마무리: 각 개념의 이해와 활용의 중요성

- **동기/비동기**: 작업 완료를 “기다리느냐, 기다리지 않느냐”라는 시간적 관점의 개념
- **블로킹/논블로킹**: 함수 호출(또는 시스템 호출)에서 “쓰레드를 멈추게 하느냐, 즉시 반환하느냐”라는 제어 흐름 관점의 개념

두 쌍의 개념은 복잡하게 얽히지만, 올바른 이해가 선행된다면 고성능·고효율 시스템을 구축할 수 있습니다.

- **동기 블로킹** 모델은 직관적이지만, 많은 동시 요청을 처리하는 대규모 시스템에는 비효율적일 수 있습니다.
- **비동기 논블로킹** 모델은 고성능 서버 구현에 탁월하지만, 설계와 디버깅이 까다롭습니다.

따라서, 프로젝트 요구사항(처리량, 응답성, 구현 난이도)을 종합적으로 고려하여 적절한 방식을 선택해야 합니다.

결국, **동기/비동기, 블로킹/논블로킹 개념을 명확히 구분**하고, 상황에 맞게 적용하는 것이 현대 소프트웨어 엔지니어링에서 매우 중요한 역량입니다.
