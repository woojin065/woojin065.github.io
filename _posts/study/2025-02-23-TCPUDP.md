---
title: TCP와 UDP 프로토콜 - 흐름 제어 및 혼잡 제어 메커니즘 비교
date: 2025-02-23 00:12:00 +09:00
categories: [common_topic]
tags: [common]
# image: 
#   path:
---


오늘날 인터넷 통신의 핵심을 이루는 TCP/IP 프로토콜 스택에서 전송 계층은 매우 중요한 역할을 담당합니다. 전송 계층은 네트워크를 통해 데이터를 안정적이고 효율적으로 전송하는 기능을 제공하며, 이 계층의 핵심 프로토콜이 바로 **TCP (Transmission Control Protocol)**와 **UDP (User Datagram Protocol)**입니다. TCP와 UDP는 애플리케이션이 네트워크 통신을 수행할 수 있도록 기본적인 인터페이스를 제공하지만, 데이터 전송 방식, 신뢰성, 속도 등 여러 측면에서 뚜렷한 차이를 보입니다.  특히 **흐름 제어 (Flow Control)**와 **혼잡 제어 (Congestion Control)** 메커니즘은 TCP와 UDP의 차이를 극명하게 보여주는 핵심적인 요소입니다. 본 글에서는 TCP와 UDP 프로토콜의 특징을 상세히 분석하고, 흐름 제어 및 혼잡 제어 메커니즘을 중심으로 두 프로토콜의 차이점을 심층적으로 비교 분석하고자 합니다.

## **2. TCP (Transmission Control Protocol) 상세 분석**

### 2.1. TCP 개요: 연결 지향형, 신뢰성 기반 프로토콜

- TCP (Transmission Control Protocol)는 **연결 지향형 (Connection-Oriented)** 프로토콜이며, **신뢰성 (Reliability)** 있는 데이터 전송을 보장하는 것을 목표로 설계되었습니다. TCP는 데이터를 전송하기 전에 송신자와 수신자 간에 논리적인 연결을 설정하고 (3-way handshake), 연결된 상태에서 데이터를 순서대로, 오류 없이, 중복 없이 전달합니다. 데이터 전송 완료 후에는 연결을 종료하는 (4-way handshake) 절차를 거칩니다. 이러한 특징 덕분에 TCP는 파일 전송, 웹 브라우징, 이메일 등 데이터의 신뢰성이 중요한 애플리케이션에서 널리 사용됩니다.

### 2.2. TCP 주요 특징

### 2.2.1. 신뢰성 있는 데이터 전송 (Reliable Data Transfer)

TCP는 다음과 같은 메커니즘을 통해 신뢰성 있는 데이터 전송을 보장합니다.

- **순서 번호 (Sequence Number):** TCP는 전송하는 모든 데이터 세그먼트에 순서 번호를 부여합니다. 수신자는 이 순서 번호를 통해 데이터 세그먼트의 순서를 확인하고, 순서가 어긋난 세그먼트를 재조립하여 데이터를 순서대로 복원할 수 있습니다.
- **확인 응답 (Acknowledgment):** 수신자는 정상적으로 수신한 데이터 세그먼트에 대해 확인 응답 (ACK) 을 송신자에게 보냅니다. 송신자는 ACK를 통해 데이터가 정상적으로 전송되었음을 확인하고, ACK를 받지 못한 데이터 세그먼트는 재전송합니다.
- **재전송 (Retransmission):** 송신자는 일정 시간 (타임아웃) 동안 ACK를 받지 못하거나, 중복된 ACK (Duplicate ACK) 를 수신하는 경우 데이터 세그먼트를 재전송합니다. 재전송 메커니즘을 통해 데이터 손실이나 오류 발생 시에도 데이터를 재전송하여 신뢰성을 확보합니다.
- **오류 검출 (Checksum):** TCP 헤더와 데이터 부분에 대한 체크섬을 계산하여 데이터 전송 중 오류 발생 여부를 검사합니다. 체크섬 오류가 발생한 데이터 세그먼트는 폐기하고 재전송을 요청합니다.

### 2.2.2. 연결 지향형 서비스 (Connection-Oriented Service)

TCP는 데이터를 전송하기 전에 반드시 송신자와 수신자 간에 **연결 설정 (Connection Establishment)** 단계를 거칩니다. 연결 설정은 **3-way handshake** 과정을 통해 이루어집니다.

1. **SYN (Synchronize Sequence Numbers):** 송신자는 수신자에게 연결 요청 메시지인 SYN 세그먼트를 보냅니다. SYN 세그먼트에는 송신자의 초기 순서 번호 (Initial Sequence Number, ISN) 가 포함됩니다.
2. **SYN-ACK (Synchronize Acknowledgment):** 수신자는 SYN 세그먼트를 수신하고, 송신자에게 SYN-ACK 세그먼트를 응답합니다. SYN-ACK 세그먼트에는 수신자의 ISN과 함께, 송신자의 ISN에 대한 ACK 번호 (ISN + 1) 가 포함됩니다.
3. **ACK (Acknowledgment):** 송신자는 SYN-ACK 세그먼트를 수신하고, 수신자에게 ACK 세그먼트를 응답합니다. ACK 세그먼트에는 수신자의 ISN에 대한 ACK 번호 (ISN + 1) 가 포함됩니다.

3-way handshake 과정을 통해 송신자와 수신자는 연결을 설정하고, 데이터 전송을 위한 준비를 마칩니다. 연결 설정 후 데이터를 양방향으로 자유롭게 주고받을 수 있으며, 데이터 전송이 완료되면 **연결 종료 (Connection Termination)** 단계를 거칩니다. 연결 종료는 **4-way handshake** 과정을 통해 이루어집니다.

1. **FIN (Finish):** 송신자 (또는 수신자) 가 연결 종료를 요청하기 위해 FIN 세그먼트를 보냅니다.
2. **ACK (Acknowledgment):** 수신자 (또는 송신자) 는 FIN 세그먼트를 수신하고, ACK 세그먼트를 응답합니다. 이는 FIN 세그먼트를 정상적으로 받았음을 알리는 응답입니다.
3. **FIN (Finish):** 수신자 (또는 송신자) 도 연결 종료 준비가 완료되면 FIN 세그먼트를 보냅니다.
4. **ACK (Acknowledgment):** 송신자 (또는 수신자) 는 마지막 FIN 세그먼트를 수신하고, ACK 세그먼트를 응답합니다. ACK 응답 후 연결이 완전히 종료됩니다.

TCP의 연결 설정 및 종료 과정은 데이터 전송의 신뢰성을 높이는 데 기여하지만, 추가적인 오버헤드를 발생시켜 UDP에 비해 속도가 느려지는 원인이 되기도 합니다.

### 2.2.3. 순서 보장 (Ordered Delivery)

TCP는 데이터 세그먼트에 순서 번호를 부여하고, 수신자는 이 순서 번호를 기반으로 데이터 세그먼트를 순서대로 재조립합니다. 네트워크 상황에 따라 데이터 세그먼트가 전송되는 순서가 바뀔 수 있지만, TCP는 순서 번호를 통해 데이터의 순서를 보장하여 애플리케이션이 데이터를 순서대로 처리할 수 있도록 합니다.

### 2.3. TCP 흐름 제어 (Flow Control)

### 2.3.1. 흐름 제어의 필요성 및 윈도우 기반 흐름 제어

- 흐름 제어 (Flow Control)는 송신자의 데이터 전송 속도를 수신자의 데이터 처리 속도에 맞춰 조절하는 메커니즘입니다. 수신자의 버퍼 크기는 제한되어 있기 때문에, 송신자가 수신자보다 빠른 속도로 데이터를 전송하면 수신자 버퍼가 오버플로우되어 데이터 손실이 발생할 수 있습니다. 흐름 제어는 이러한 데이터 손실을 방지하고 효율적인 데이터 전송을 보장하기 위해 필요합니다.

TCP는 **윈도우 기반 흐름 제어 (Window-based Flow Control)** 방식을 사용합니다. 수신자는 **수신 윈도우 (Receiver Window, rwnd)** 값을 통해 자신이 현재 수용 가능한 데이터의 양을 송신자에게 알립니다. 송신자는 수신 윈도우 값을 참고하여 자신이 전송할 수 있는 데이터의 양을 조절합니다. 즉, 송신자는 수신 윈도우 크기 내에서만 ACK를 받지 않은 데이터 세그먼트를 전송할 수 있습니다.

- **수신 윈도우 (rwnd):** 수신자가 데이터를 수신하고 버퍼에 저장할 수 있는 여유 공간을 나타내는 값입니다. 수신자는 ACK 세그먼트를 통해 rwnd 값을 송신자에게 알립니다. rwnd 값은 수신자의 버퍼 상황에 따라 동적으로 변할 수 있습니다. 수신자 버퍼에 여유 공간이 많으면 rwnd 값을 크게 하여 송신자의 전송 속도를 높이고, 버퍼 공간이 부족하면 rwnd 값을 작게 하여 송신자의 전송 속도를 늦춥니다.
- **송신 윈도우 (Sender Window, swnd 또는 cwnd):** 송신자가 수신자에게 ACK를 받지 않고 전송할 수 있는 최대 데이터 양을 나타내는 값입니다. 송신 윈도우는 흐름 제어와 혼잡 제어 메커니즘에 의해 결정됩니다. 흐름 제어 관점에서 송신 윈도우는 수신 윈도우 (rwnd) 값에 의해 제한됩니다. 즉, 송신 윈도우는 항상 rwnd 값보다 작거나 같아야 합니다.

흐름 제어를 통해 송신자는 수신자의 처리 능력에 맞춰 데이터 전송 속도를 조절하여 수신자 버퍼 오버플로우를 방지하고 데이터 손실을 최소화할 수 있습니다.

### 2.4. TCP 혼잡 제어 (Congestion Control)

### 2.4.1. 혼잡 제어의 필요성 및 혼잡 제어 알고리즘

- **혼잡 제어 (Congestion Control)**는 네트워크 내에 데이터가 과도하게 몰려 발생하는 **혼잡 (Congestion)** 현상을 방지하고 네트워크 성능을 유지하기 위한 메커니즘입니다. 네트워크 혼잡은 여러 송신자가 동시에 많은 양의 데이터를 네트워크로 전송할 때 발생하며, 패킷 손실, 지연 시간 증가 등 네트워크 성능 저하를 야기합니다. 혼잡 제어는 네트워크 혼잡을 감지하고, 송신자의 데이터 전송 속도를 조절하여 네트워크 혼잡을 완화하는 역할을 합니다.

TCP는 네트워크 혼잡을 제어하기 위해 다양한 혼잡 제어 알고리즘 (Congestion Control Algorithm)을 사용합니다. 대표적인 혼잡 제어 알고리즘으로는 **슬로우 스타트 (Slow Start), 혼잡 회피 (Congestion Avoidance), 빠른 재전송 (Fast Retransmit), 빠른 회복 (Fast Recovery)** 등이 있습니다. 이러한 알고리즘들은 송신 윈도우 (cwnd, Congestion Window) 값을 동적으로 조절하여 네트워크 혼잡을 제어합니다.

### 2.4.2. 혼잡 윈도우 (Congestion Window, cwnd)

- *혼잡 윈도우 (Congestion Window, cwnd)**는 송신자가 네트워크 혼잡 상황을 고려하여 전송할 수 있는 최대 데이터 양을 나타내는 값입니다. 송신 윈도우는 흐름 제어에 의해 제한되는 수신 윈도우 (rwnd) 값과 혼잡 제어에 의해 제한되는 혼잡 윈도우 (cwnd) 값 중 작은 값으로 결정됩니다. 즉, 송신 윈도우 = min (rwnd, cwnd) 입니다.

### 2.4.3. 슬로우 스타트 (Slow Start)

- *슬로우 스타트 (Slow Start)**는 TCP 연결이 처음 시작되거나, 타임아웃과 같은 심각한 혼잡 상황 이후 네트워크 상태를 점진적으로 탐색하는 알고리즘입니다. 슬로우 스타트 단계에서는 cwnd 값을 매우 작은 값 (일반적으로 1-4 MSS, Maximum Segment Size) 으로 시작하여, ACK를 받을 때마다 cwnd 값을 1 MSS씩 **지수적으로 증가**시킵니다. 슬로우 스타트는 네트워크의 초기 대역폭을 빠르게 활용하여 전송 속도를 빠르게 증가시키는 장점이 있지만, cwnd 값이 급격하게 증가하여 네트워크 혼잡을 유발할 수 있는 위험성도 가지고 있습니다. cwnd 값이 **슬로우 스타트 임계값 (Slow Start Threshold, ssthresh)** 에 도달하면 슬로우 스타트 단계에서 혼잡 회피 단계로 전환됩니다.

### 2.4.4. 혼잡 회피 (Congestion Avoidance)

- *혼잡 회피 (Congestion Avoidance)**는 슬로우 스타트 단계 이후, cwnd 값이 ssthresh 값 이상이 되면 네트워크 혼잡을 완만하게 탐색하는 알고리즘입니다. 혼잡 회피 단계에서는 ACK를 받을 때마다 cwnd 값을 1 MSS씩 **선형적으로 증가**시킵니다. 혼잡 회피는 cwnd 값 증가 속도를 슬로우 스타트보다 늦춰 네트워크 혼잡 발생 가능성을 줄이면서 안정적으로 전송 속도를 증가시키는 역할을 합니다. 혼잡 회피 단계에서 타임아웃과 같은 혼잡 신호가 감지되면 cwnd 값과 ssthresh 값을 감소시키고 슬로우 스타트 단계로 다시 진입하거나, 빠른 재전송/빠른 회복 알고리즘을 통해 혼잡 상황에 대처합니다.

### 2.4.5. 빠른 재전송 (Fast Retransmit)

- *빠른 재전송 (Fast Retransmit)**은 타임아웃 발생 전에 데이터 손실을 감지하고 빠르게 재전송하는 알고리즘입니다. 수신자가 순서에 맞지 않은 데이터 세그먼트를 수신하면, 순서가 맞지 않은 세그먼트 이후의 세그먼트에 대한 ACK를 보내지 않고, 이전에 정상적으로 수신한 마지막 세그먼트에 대한 **중복 ACK (Duplicate ACK)**를 송신자에게 보냅니다. 송신자가 동일한 순서 번호의 중복 ACK를 3개 (Triple Duplicate ACK) 이상 수신하면, 타임아웃이 발생하기 전에 데이터 손실이 발생했다고 판단하고 해당 세그먼트를 즉시 재전송합니다. 빠른 재전송은 불필요한 타임아웃 대기 시간을 줄여 데이터 전송 효율을 높이고, 혼잡 상황에 빠르게 대처하는 데 기여합니다.

### 2.4.6. 빠른 회복 (Fast Recovery)

- *빠른 회복 (Fast Recovery)**은 빠른 재전송 알고리즘과 함께 사용되는 혼잡 제어 알고리즘입니다. 빠른 재전송을 통해 데이터 손실이 감지되면, cwnd 값을 절반으로 줄이고 ssthresh 값을 현재 cwnd 값으로 설정합니다. 그 후, 혼잡 회피 단계를 통해 cwnd 값을 점진적으로 증가시키면서 네트워크 혼잡 상황에서 빠르게 회복하는 것을 목표로 합니다. 빠른 회복은 타임아웃 발생 시 슬로우 스타트 단계로 돌아가는 것에 비해 cwnd 값을 크게 감소시키지 않고 혼잡 회피 단계를 통해 회복하므로, 전송 속도 감소폭을 줄이고 네트워크 성능 저하를 최소화하는 효과를 제공합니다.

## **3. UDP (User Datagram Protocol) 상세 분석**

### 3.1. UDP 개요: 비연결 지향형, 비신뢰성 기반 프로토콜

- **UDP (User Datagram Protocol)**는 **비연결 지향형 (Connectionless)** 프로토콜이며, **비신뢰성 (Unreliability)** 기반의 데이터 전송을 제공합니다. TCP와 달리 UDP는 데이터를 전송하기 전에 연결 설정 단계를 거치지 않고, 단순히 데이터를 캡슐화하여 네트워크로 전송합니다. 데이터 전송 순서 보장, 오류 검출, 재전송, 흐름 제어, 혼잡 제어 등 TCP가 제공하는 다양한 신뢰성 메커니즘을 제공하지 않습니다. 이러한 단순함 덕분에 UDP는 TCP에 비해 오버헤드가 적고 속도가 빠르며, 실시간 스트리밍, 온라인 게임, DNS 등 속도가 중요하고 약간의 데이터 손실은 허용 가능한 애플리케이션에 적합합니다.

### 3.2. UDP 주요 특징

### 3.2.1. 비연결 지향형 서비스 (Connectionless Service)

UDP는 TCP와 달리 연결 설정 및 종료 단계를 거치지 않습니다. 송신자는 데이터를 전송하기 전에 수신자와 연결을 설정하는 과정 없이 바로 데이터를 전송합니다. UDP는 각 데이터그램을 독립적으로 전송하며, 데이터그램 간의 순서, 연결 상태 등을 관리하지 않습니다. 비연결성은 TCP에 비해 오버헤드를 줄이고 속도를 향상시키는 장점이 있지만, 데이터 전송의 신뢰성을 보장하지 못한다는 단점도 가지고 있습니다.

### 3.2.2. 비신뢰성 데이터 전송 (Unreliable Data Transfer)

UDP는 TCP와 달리 데이터 전송의 신뢰성을 보장하기 위한 메커니즘을 제공하지 않습니다. UDP는 데이터그램을 전송하고 나서 데이터가 목적지에 정상적으로 도착했는지, 순서대로 도착했는지, 중복되지는 않았는지 등을 확인하지 않습니다. 데이터 전송 중 오류가 발생하거나, 데이터그램이 손실되거나, 순서가 바뀌거나, 중복될 수 있습니다. UDP는 데이터 전송의 신뢰성을 애플리케이션 레벨에서 직접 관리해야 합니다. 하지만, UDP의 비신뢰성은 속도와 효율성을 중시하는 애플리케이션에게는 오히려 장점이 될 수 있습니다.

### 3.2.3. 단순하고 빠른 속도 (Simple and Fast)

UDP는 TCP에 비해 헤더 구조가 단순하고, 연결 설정 및 종료, 순서 보장, 흐름 제어, 혼잡 제어 등 다양한 부가 기능을 제공하지 않기 때문에 오버헤드가 매우 적습니다. UDP 헤더는 출발지 포트, 목적지 포트, 길이, 체크섬 등 최소한의 정보만 포함합니다. 이러한 단순함 덕분에 UDP는 TCP에 비해 데이터 처리 속도가 빠르고, 네트워크 대역폭을 효율적으로 사용할 수 있습니다. 속도가 중요한 실시간 스트리밍, 온라인 게임 등 애플리케이션에서 UDP가 널리 사용되는 이유입니다.

### 3.3. UDP 흐름 제어 및 혼잡 제어 부재

### 3.3.1. UDP 흐름 제어 부재

UDP는 **흐름 제어 메커니즘을 제공하지 않습니다.** UDP는 송신자의 데이터 전송 속도를 수신자의 데이터 처리 속도에 맞춰 조절하는 기능을 가지고 있지 않습니다. 따라서 UDP를 사용하는 애플리케이션은 수신자의 버퍼 오버플로우 가능성을 고려하여 자체적으로 흐름 제어를 구현하거나, 흐름 제어 없이 데이터를 전송해야 합니다. 흐름 제어가 없는 UDP 환경에서는 수신자 버퍼 오버플로우로 인한 데이터 손실이 발생할 수 있으며, 애플리케이션은 데이터 손실에 대한 대비책을 마련해야 합니다.

### 3.3.2. UDP 혼잡 제어 부재

UDP는 **혼잡 제어 메커니즘 또한 제공하지 않습니다.** UDP는 네트워크 혼잡 상황을 감지하고 송신 속도를 조절하는 기능을 가지고 있지 않습니다. UDP를 사용하는 애플리케이션은 네트워크 혼잡 상황을 고려하지 않고 데이터를 전송할 수 있으며, 이는 네트워크 혼잡을 악화시킬 수 있습니다. UDP 기반 애플리케이션이 네트워크 혼잡을 유발하는 것을 방지하기 위해, 일부 애플리케이션은 자체적으로 혼잡 제어 메커니즘을 구현하기도 합니다. 하지만, 대부분의 UDP 기반 애플리케이션은 혼잡 제어 없이 데이터를 전송하며, 네트워크 혼잡 제어는 네트워크 관리자의 책임으로 남겨지는 경우가 많습니다.

### 3.3.3. UDP 흐름 제어 및 혼잡 제어 부재 이유

UDP가 흐름 제어 및 혼잡 제어 메커니즘을 제공하지 않는 이유는 다음과 같습니다.

- **단순성 및 속도:** UDP는 단순하고 빠른 속도를 목표로 설계되었기 때문에, 복잡한 흐름 제어 및 혼잡 제어 기능을 추가하지 않았습니다.
- **애플리케이션 제어:** UDP는 흐름 제어 및 혼잡 제어를 애플리케이션 레벨에서 구현할 수 있도록 유연성을 제공합니다. 애플리케이션은 필요에 따라 자체적인 흐름 제어 및 혼잡 제어 메커니즘을 구현하거나, 이러한 제어 없이 데이터를 전송할 수 있습니다.
- **특정 애플리케이션 요구:** 실시간 스트리밍, 온라인 게임 등 일부 애플리케이션은 데이터의 신뢰성보다 속도와 실시간성을 더 중요하게 생각합니다. 이러한 애플리케이션에게는 UDP의 단순함과 속도가 더 적합하며, 흐름 제어 및 혼잡 제어 오버헤드를 줄이는 것이 유리합니다.

**4. TCP와 UDP 비교 분석**

### 4.1. 기능 및 특징 비교

| 특징 | TCP | UDP |
| --- | --- | --- |
| 연결 방식 | 연결 지향형 (Connection-Oriented) | 비연결 지향형 (Connectionless) |
| 신뢰성 | 신뢰성 있는 데이터 전송 (Reliable) | 비신뢰성 데이터 전송 (Unreliable) |
| 순서 보장 | 데이터 순서 보장 (Ordered Delivery) | 데이터 순서 보장 안 함 (Unordered Delivery) |
| 흐름 제어 | 윈도우 기반 흐름 제어 (Flow Control) | 흐름 제어 없음 (No Flow Control) |
| 혼잡 제어 | 혼잡 제어 (Congestion Control) | 혼잡 제어 없음 (No Congestion Control) |
| 속도 | UDP에 비해 느림 | TCP에 비해 빠름 |
| 오버헤드 | UDP에 비해 큼 | TCP에 비해 작음 |
| 헤더 크기 | UDP에 비해 큼 (20 bytes) | TCP에 비해 작음 (8 bytes) |
| 사용 사례 | 웹 브라우징 (HTTP, HTTPS), 이메일 (SMTP), 파일 전송 (FTP, SFTP), 원격 접속 (SSH, Telnet) 등 | 실시간 스트리밍 (비디오, 오디오), 온라인 게임, VoIP, DNS 등 |

### 4.2. 주요 사용 사례 비교

- **TCP 주요 사용 사례:**
    - **웹 브라우징 (HTTP, HTTPS):** 웹 페이지, 이미지, 텍스트 등 웹 콘텐츠는 데이터 손실 없이 정확하게 전달되어야 하므로 TCP가 사용됩니다. HTTPS는 보안 강화를 위해 TCP 기반 위에 SSL/TLS 프로토콜을 추가하여 사용합니다.
    - **이메일 (SMTP, POP3, IMAP):** 이메일 메시지는 오류 없이 정확하게 전달되어야 하므로 TCP가 사용됩니다. SMTP는 이메일 전송, POP3/IMAP은 이메일 수신에 사용됩니다.
    - **파일 전송 (FTP, SFTP):** 파일은 손실 없이 완벽하게 전송되어야 하므로 TCP가 사용됩니다. FTP는 파일 전송 프로토콜, SFTP는 보안 파일 전송 프로토콜입니다.
    - **원격 접속 (SSH, Telnet):** 원격 시스템에 안전하게 접속하고 명령을 실행하기 위해서는 TCP의 신뢰성 있는 연결이 필수적입니다. SSH는 보안 원격 접속, Telnet은 비보안 원격 접속 프로토콜입니다.
- **UDP 주요 사용 사례:**
    - **실시간 스트리밍 (비디오, 오디오):** 실시간 스트리밍은 속도와 실시간성이 중요하며, 약간의 데이터 손실은 화질 저하나 끊김 현상으로 나타날 수 있지만, 전체 서비스 품질에 큰 영향을 미치지 않습니다. 따라서 UDP를 사용하여 빠른 속도를 확보하고, 데이터 손실은 애플리케이션 레벨에서 보정하거나 허용하는 경우가 많습니다.
    - **온라인 게임:** 온라인 게임은 빠른 응답 속도와 실시간성이 매우 중요합니다. UDP는 TCP에 비해 지연 시간이 짧고 속도가 빠르기 때문에 온라인 게임 트래픽 전송에 적합합니다. 게임 데이터 손실은 게임 플레이에 일시적인 문제를 일으킬 수 있지만, 게임 진행 자체를 멈추게 하지는 않으므로 UDP의 비신뢰성을 감수하고 속도를 우선시합니다.
    - **VoIP (Voice over IP):** 음성 통화는 실시간성이 중요하며, 약간의 음성 데이터 손실은 음질 저하를 유발할 수 있지만, 통화 자체가 불가능해지는 것은 아닙니다. 따라서 UDP를 사용하여 실시간성을 확보하고, 음성 데이터 손실은 음성 코덱이나 애플리케이션 레벨에서 보정하는 경우가 많습니다.
    - **DNS (Domain Name System):** DNS 쿼리는 빠른 응답 시간이 중요하며, 쿼리 손실 시 재전송 메커니즘을 통해 신뢰성을 확보할 수 있습니다. UDP는 DNS 쿼리에 대한 빠른 응답 속도를 제공하며, 쿼리 실패 시 재시도를 통해 신뢰성을 보완할 수 있습니다.

**5. 결론**

TCP와 UDP는 전송 계층에서 중요한 역할을 수행하는 프로토콜이지만, 설계 목표와 특징이 뚜렷하게 다릅니다. TCP는 신뢰성 있는 데이터 전송을 보장하기 위해 연결 설정, 순서 보장, 흐름 제어, 혼잡 제어 등 다양한 메커니즘을 제공하지만, 오버헤드가 크고 속도가 UDP에 비해 느립니다. 반면, UDP는 단순하고 빠른 속도를 위해 연결 설정, 신뢰성 메커니즘, 흐름 제어, 혼잡 제어 등을 생략하여 오버헤드를 최소화하고 속도를 극대화합니다.

애플리케이션 개발자는 애플리케이션의 요구사항 (신뢰성, 속도, 실시간성 등) 을 고려하여 적절한 전송 프로토콜을 선택해야 합니다. 데이터의 신뢰성이 중요한 애플리케이션 (웹 브라우징, 이메일, 파일 전송 등) 에는 TCP가 적합하며, 속도와 실시간성이 중요한 애플리케이션 (스트리밍, 온라인 게임, VoIP 등) 에는 UDP가 더 적합합니다. TCP와 UDP 프로토콜의 특징과 차이점을 명확하게 이해하고, 애플리케이션 요구사항에 맞는 프로토콜을 선택하는 것은 효율적인 네트워크 애플리케이션 개발에 매우 중요합니다.