---
title: 트랜젝션
date: 2025-02-08 00:10:00 +09:00
categories: [common_topic]
tags: [common]
image: /images/2025/2-8-Transactions.png
---

현대의 데이터베이스 시스템은 복잡한 애플리케이션 환경에서 신뢰성과 일관성을 보장하기 위해 **트랜잭션(Transaction)**이라는 개념을 필수적으로 도입하고 있습니다. 본 글에서는 트랜잭션의 기본 개념부터 동시성 제어, 분산 트랜잭션, 그리고 최신 연구 동향까지 폭넓게 다루며, 실제 시스템에서 트랜잭션을 어떻게 관리하고 최적화하는지 살펴보겠습니다.

---

## 1. 트랜잭션(Transaction)이란?

![image.png](/images/2025/2-8-Transactions.png)

### 트랜잭션의 정의와 개념

![image.png](/images/2025/2-8-Transactions1.png)

트랜잭션은 **데이터베이스 작업의 논리적 연산 단위**를 말합니다. 즉, 여러 개의 SQL 연산(INSERT, UPDATE, DELETE, SELECT 등)이 하나의 트랜잭션으로 묶여 **모두 성공하거나 모두 실패**해야 하는 특성을 가집니다.

- 예를 들어, `계좌 이체`를 수행할 때 **A 계좌에서 출금**하고 **B 계좌에 입금**하는 두 개의 연산은 **하나의 트랜잭션**이 됩니다. 둘 중 하나라도 실패하면 전체 연산을 되돌려야(ROLLBACK) 합니다.

### 데이터베이스에서 트랜잭션이 중요한 이유

- **데이터 무결성 보장**: 트랜잭션은 작업 중에 예기치 않은 오류(전원 장애, 네트워크 단절 등)가 발생해도 데이터의 일관성과 무결성을 유지하게 해줍니다.
- **안정적인 운영**: 중요한 비즈니스 로직(예: 결제, 재고 처리 등)이 중간에 실패하더라도 복구가 가능하므로, 시스템 신뢰도가 높아집니다.

## 2. 트랜잭션의 기본 개념

### ACID 원칙

![image.png](/images/2025/2-8-Transactions2.png)

트랜잭션의 신뢰성을 보장하는 네 가지 핵심 속성은 다음과 같습니다.

- **원자성(Atomicity)**:
    
    ![image.png](/images/2025/2-8-Transactions3.png)
    
    트랜잭션 내의 모든 연산은 하나의 단위로 처리되어야 합니다. 즉, 모든 연산이 성공해야 커밋되고, 하나라도 실패하면 전체가 롤백되어야 합니다.
    
- **일관성(Consistency)**:
    
    ![image.png](/images/2025/2-8-Transactions4.png)
    
    트랜잭션이 실행되기 전후에 데이터베이스는 항상 정의된 규칙(무결성 제약조건, 비즈니스 규칙 등)을 만족해야 합니다. 이는 데이터베이스의 상태가 항상 일관된 상태임을 보장합니다.
    
- **격리성(Isolation)**:
    
    ![image.png](/images/2025/2-8-Transactions5.png)
    
    동시에 실행되는 여러 트랜잭션은 서로의 작업에 영향을 주지 않아야 합니다. 각 트랜잭션은 독립적으로 처리되어, 동시성 문제로 인한 데이터 충돌을 방지합니다.
    
- **지속성(Durability)**:
    
    ![image.png](/images/2025/2-8-Transactions6.png)
    
    트랜잭션이 커밋된 후, 시스템 장애가 발생하더라도 그 결과는 영구적으로 데이터베이스에 반영되어야 합니다. 이를 위해 로그 기록과 백업 전략이 중요하게 작용합니다.
    

### 트랜잭션의 상태와 생명주기

트랜잭션은 보통 다음과 같은 단계로 진행됩니다.

1. **시작(Begin)**: 트랜잭션이 시작되며, 데이터베이스는 작업의 초기 상태를 기록합니다.
2. **실행(Execution)**: 여러 데이터 조작 연산이 순차적으로 수행됩니다.
3. **커밋(Commit)**: 모든 연산이 성공하면, 변경 사항을 영구적으로 반영하고 트랜잭션을 종료합니다.
4. **롤백(Rollback)**: 오류 발생 시, 트랜잭션의 모든 변경 사항을 취소하여 이전 상태로 복구합니다.

이러한 상태 전이 과정을 다이어그램으로 표현하면, 트랜잭션 관리의 흐름과 복구 메커니즘을 명확히 이해할 수 있습니다.

---

## 3. 트랜잭션 격리 수준과 동시성 제어

### 격리 수준(Isolation Levels)

동시성 제어를 위해 DBMS는 여러 격리 수준을 지원하며, 각각은 성능과 일관성 사이의 균형을 다르게 맞춥니다.

- **Read Uncommitted**:
    
    ![image.png](/images/2025/2-8-Transactions7.png)
    
    아직 커밋되지 않은 데이터를 읽을 수 있으므로, 가장 낮은 격리 수준이며 '더러운 읽기(Dirty Read)'가 발생할 수 있습니다.
    
- **Read Committed**:
    
    ![image.png](/images/2025/2-8-Transactions8.png)
    
    커밋된 데이터만 읽을 수 있어, 더러운 읽기를 방지하지만 반복 읽기(Non-repeatable Read)(=같은 데이터를 조회했는데, 값이 바뀌어버린 경우) 문제는 발생할 수 있습니다.
    
- **Repeatable Read**:
    
    ![image.png](/images/2025/2-8-Transactions9.png)
    
    트랜잭션 동안 읽은 데이터가 변하지 않음을 보장하지만, 팬텀 리드(Phantom Read)(=같은 조건으로 조회했는데, 새로운 데이터가 추가되어 결과가 바뀐 경우)는 여전히 발생할 수 있습니다.
    
- **Serializable**:
    
    ![image.png](/images/2025/2-8-Transactions10.png)
    
    가장 높은 격리 수준으로, 모든 트랜잭션이 순차적으로 실행된 것처럼 보장하지만, 성능 저하의 원인이 될 수 있습니다. 또한 데드락(Deadlock)과 트랜잭션 블로킹(Blocking)으로 인한 시스템 정체가 일어날 수 있습니다.
    

### 요약

| 격리 수준 | Dirty Read 방지 | Non-Repeatable Read 방지 | Phantom Read 방지 | 성능 영향 | 주요 사용 사례 |
| --- | --- | --- | --- | --- | --- |
| **Read Uncommitted** | ❌ 허용됨 | ❌ 발생 가능 | ❌ 발생 가능 | 매우 낮음 (가장 빠름) | 로그 저장, 임시 데이터 조회 (정확성보다 속도가 중요한 경우) |
| **Read Committed** | ✅ 방지됨 | ❌ 발생 가능 | ❌ 발생 가능 | 낮음 (빠름) | 대부분의 트랜잭션 기반 시스템 (은행, 쇼핑몰 등) |
| **Repeatable Read** | ✅ 방지됨 | ✅ 방지됨 | ❌ 발생 가능 | 중간 | 쇼핑몰 결제, 재고 관리, 금융 거래 (데이터 정합성 중요) |
| **Serializable** | ✅ 방지됨 | ✅ 방지됨 | ✅ 방지됨 | 높음 (느림) | 좌석 예약 시스템, 금융 시스템 (가장 높은 정합성이 필요한 경우) |

### 동시성 제어 메커니즘

동시성 제어는 여러 트랜잭션이 동시에 진행될 때 발생할 수 있는 데이터 충돌을 방지하는 핵심 메커니즘입니다.

- **잠금 기반 제어(Locking Mechanisms)**:
    - **공유 잠금(Shared Lock)**: 여러 트랜잭션이 동시에 데이터를 읽을 수 있도록 허용합니다.
    - **배타 잠금(Exclusive Lock)**: 데이터를 수정할 때 사용되며, 해당 데이터에 대한 다른 접근을 차단합니다.
    - **의도적 잠금(Intent Lock)**: 데이터베이스의 계층적 구조에서 상위-하위 간의 잠금 충돌을 방지하기 위한 잠금 유형입니다.
- **낙관적 동시성 제어(Optimistic Concurrency Control)**:
    
    충돌 가능성이 낮은 상황에서, 트랜잭션이 먼저 실행된 후 충돌 여부를 검증하는 방식입니다.
    
- **다중 버전 동시성 제어(MVCC)**:
    
    각 트랜잭션이 데이터의 스냅샷을 참조하도록 하여, 읽기 작업이 쓰기 작업에 의해 방해받지 않도록 합니다. PostgreSQL과 Oracle 등의 DBMS가 MVCC를 채택하고 있습니다.
    

### 직렬화 이론과 스케줄링

- **직렬 가능 스케줄(Serializability)**:동시 실행되는 트랜잭션들의 결과가 순차 실행한 것과 동일한지를 검증하는 기준입니다.
- **스냅샷 격리(Snapshot Isolation)**:트랜잭션이 시작될 때의 데이터 스냅샷을 기반으로 작업을 수행하여, 판독 일관성을 보장하는 방법입니다.

---

## 4. 트랜잭션 관리 및 복구 기법

### 트랜잭션 관리자(Transaction Manager)의 역할

트랜잭션 관리자는 트랜잭션의 시작, 실행, 커밋, 롤백 등의 전 과정을 관리합니다. 이 과정에서 로그 기록, 잠금 관리, 오류 처리 등을 통해 데이터베이스의 일관성과 신뢰성을 유지합니다.

### 로그와 Write-Ahead Logging (WAL)

- **트랜잭션 로그**:모든 데이터 변경 내역을 기록하는 로그 파일은 장애 발생 시 복구 작업의 핵심 자료로 활용됩니다.
- **Write-Ahead Logging (WAL)**:실제 데이터 변경 이전에 로그 기록을 먼저 수행함으로써, 장애 발생 시 로그를 기반으로 데이터 복구가 가능하도록 합니다.

### Deadlock 감지 및 회피

- **Deadlock(교착 상태)**:서로 다른 트랜잭션이 서로의 잠금을 기다리면서 무한 대기 상태에 빠지는 현상입니다.
- **감지 및 해결 방법**:주기적인 교착 상태 감지 알고리즘(예: wait-for graph 분석)과 타임아웃, 강제 롤백 등의 방법을 통해 Deadlock을 해결할 수 있습니다.

---

## 5. 분산 트랜잭션과 프로토콜

### 분산 환경에서의 트랜잭션 필요성

현대 애플리케이션은 여러 노드, 심지어 여러 데이터 센터에 걸쳐 분산되어 운영되기 때문에, 분산 트랜잭션은 여러 노드 간의 데이터 일관성을 보장하는 데 필수적입니다.

### Two-Phase Commit (2PC) 프로토콜

- **2PC의 작동 원리**:모든 참가자에게 커밋 가능 여부를 확인하는 **prepare phase**와, 최종적으로 커밋 여부를 통보하는 **commit phase**로 나뉩니다.
- **한계**:네트워크 장애나 coordinator의 실패 시, 전체 시스템의 응답 지연 및 블로킹(blocking) 문제가 발생할 수 있습니다.

### Three-Phase Commit (3PC) 및 기타 분산 트랜잭션 프로토콜

- **3PC**:2PC의 단점을 보완하기 위해 도입된 프로토콜로, 추가적인 준비 단계(Pre-commit 단계)를 두어 보다 안전하게 트랜잭션을 종료할 수 있도록 합니다.
- **최신 동향**:최근에는 CAP 이론과 분산 시스템의 요구를 반영하여, 트랜잭션의 일관성과 가용성 사이의 트레이드오프를 고려한 다양한 프로토콜(예: Paxos, Raft 기반 분산 합의 알고리즘)도 연구되고 있습니다.

---

## 6. 최신 트렌드와 실제 적용 사례

### NewSQL과 하이브리드 모델

- **NewSQL**:전통적 RDBMS의 ACID 특성을 유지하면서도 NoSQL이 제공하는 수평적 확장성을 구현한 최신 시스템입니다. Google Spanner, CockroachDB 등이 대표적입니다.
- **하이브리드 모델**:일부 애플리케이션은 ACID와 BASE 접근법을 혼합하여, 특정 상황에서는 강한 일관성을, 다른 상황에서는 높은 확장성을 선택하는 전략을 사용합니다.

### ACID vs. BASE

- **ACID**:트랜잭션의 전통적 모델로, 강한 일관성과 무결성을 보장합니다.
- **BASE**:기본적으로 NoSQL 시스템에서 채택하는 접근 방식으로, **Basically Available, Soft state, Eventual consistency**의 개념을 따르며, 단기적인 불일치 허용을 통해 높은 확장성과 가용성을 제공합니다.

### 클라우드와 분산 환경에서의 트랜잭션 처리

마이크로서비스 아키텍처와 클라우드 네이티브 환경에서는 단일 DBMS에 의존하지 않고, 서비스 간 분산 트랜잭션 혹은 Saga 패턴 등을 통해 데이터 일관성을 유지하는 전략이 활발히 연구되고 있습니다.

### 주요 DBMS의 트랜잭션 처리 사례 연구

- **전통적 RDBMS**: Oracle, PostgreSQL, MySQL 등은 ACID를 엄격하게 준수하면서 다양한 동시성 제어 메커니즘과 복구 기법을 제공합니다.
- **NoSQL 시스템**: MongoDB, Cassandra 등은 기본적으로 강한 일관성보다는 확장성과 성능에 초점을 맞추지만, 최근 트랜잭션 지원 기능을 강화하고 있습니다.