---
title: 멀티쓰레딩과 성능
date: 2025-01-11 00:00:00 +09:00
categories: [common_topic]
tags: [common]
image: 
---

# 들어가며: 멀티쓰레딩이란 무엇이며 왜 중요한가?

현대의 컴퓨터 시스템(특히 멀티코어 CPU가 탑재된 환경)에서는 하나의 프로그램 안에서 여러 작업을 동시에 처리할 수 있는 방법이 필요합니다. 이를 위해 **멀티쓰레딩(Multi-Threading)**이라는 기법이 자주 활용됩니다.

> “In computer architecture, multithreading is the ability of a CPU to provide multiple threads of execution simultaneously.”

**멀티쓰레딩**은 하나의 프로세스(Process) 내부에서 여러 실행 흐름(스레드, Thread)을 생성하고, 이 스레드들이 프로세스 자원을 공유하면서 독립적으로 동작하도록 하는 개념입니다. 이러한 멀티쓰레딩을 적절히 활용하면, CPU 사용률을 최대한 끌어올리고 입출력(I/O) 병목을 줄여 프로그램의 **응답성**과 **처리량(Throughput)**을 동시에 개선할 수 있습니다.

---

# 1. 멀티쓰레딩의 작동 원리

## 1.1 쓰레드 생성과 관리

1. **쓰레드 생성**
   - 프로세스가 실행 중인 상태에서, 개발자가 명시적으로 쓰레드를 생성할 수 있습니다.
   - C/C++에서는 **pthread** 라이브러리나 C++ 표준 라이브러리의 `std::thread`를 통해, Java에서는 `Thread` 클래스를 통해 쓰레드를 생성합니다.
   - 스레드는 프로세스의 코드, 데이터, 힙 등을 공유하지만, 각자 고유의 스택(Stack)과 레지스터 집합(Program Counter, CPU 레지스터 등)을 갖습니다.
2. **쓰레드 스케줄링**
   - 운영체제 또는 런타임이 쓰레드를 스케줄링하여 CPU를 할당합니다.
   - 여러 쓰레드가 동시에 실행 대기 상태일 때, 우선순위나 타임슬라이스 등을 고려해 CPU를 차례로 배분합니다.
3. **종료와 자원 정리**
   - 스레드가 맡은 작업을 모두 마치거나 예외로 인해 종료되면, 운영체제는 해당 스레드의 스택과 관련 자원을 회수합니다.
   - 프로세스가 종료될 경우, 해당 프로세스의 모든 스레드도 함께 종료됩니다.

## 1.2 컨텍스트 스위칭과 오버헤드

- **컨텍스트 스위칭(Context Switching)**
  - CPU가 실행 중이던 스레드(또는 프로세스)의 상태를 저장하고, 다른 스레드(또는 프로세스)의 상태를 복원하는 과정을 말합니다.
  - 스레드 간 전환이 프로세스 간 전환보다 가벼운 편이지만, 스위칭 자체가 “비용(오버헤드)”을 수반합니다.
- **오버헤드와 최적화**
  - 컨텍스트 스위칭이 잦으면 CPU가 “실제 작업”보다는 “문맥 전환”에 더 많은 시간을 소비할 수 있습니다.
  - 따라서, 스레드 수와 스케줄링 정책을 잘 설계해 과도한 스위칭을 방지하는 것이 중요합니다.

---

# 2. 멀티쓰레딩이 성능에 미치는 영향

## 2.1 병렬 처리로 인한 성능 향상

- **멀티코어 시대의 필수 전략**
  - 2코어, 4코어, 8코어 등 멀티코어 프로세서가 일반화되면서, 여러 코어에서 병렬로 작업을 수행할 수 있는 환경이 마련되었습니다.
  - 멀티쓰레드로 코드를 작성하면, 각 스레드가 서로 다른 코어에서 병렬로 실행되어 **실질적인 처리량**이 늘어납니다.
- **Amdahl’s Law**
  - “프로그램의 병렬화 가능한 부분이 많을수록 성능 향상 폭이 커진다”는 법칙입니다.
  - 한 작업이 80% 정도 병렬화가 가능하다면, 남은 20%의 직렬(Serial) 구간이 전체 속도를 제한하는 병목(Bottleneck)이 됩니다.
  - 멀티쓰레딩 설계 시, 병렬화하기 어려운 부분을 최소화하고 병렬 처리 구간을 최대화해야 높은 성능 개선을 기대할 수 있습니다.

## 2.2 CPU 및 I/O 활용 최적화

- **CPU 바운드(Compute-Bound) 작업**
  - 복잡한 수치 연산, 암호화·복호화, 머신러닝 모델 학습 등 CPU 연산량이 많은 작업에서는 여러 쓰레드가 동시에 계산하면 처리 속도가 크게 향상됩니다.
  - 단, 전역 인터프리터 락(GIL) 같은 언어적 제약이 있는 경우(예: Python), 멀티프로세스를 써야 하는 상황도 있습니다.
- **I/O 바운드(I/O-Bound) 작업**
  - 파일 읽기/쓰기, 네트워크 통신, 데이터베이스 접근 등에서 대기 시간이 많다면, 다른 스레드가 그 사이 CPU를 활용할 수 있습니다.
  - 멀티쓰레딩으로 I/O 대기를 효율적으로 숨기면, 응답성과 처리량(Throughput)을 동시에 높일 수 있습니다.

---

# 3. 멀티쓰레딩의 한계

## 3.1 락(Lock)과 경쟁 상태(Race Condition)

- **락(Lock)**
  - 여러 스레드가 동시에 공유 자원(예: 전역 변수, 리스트, 큐 등)에 접근해서 수정할 때, 데이터 무결성(Data Integrity)을 보장하기 위해 설정하는 “잠금”입니다.
  - 락이 없으면 스레드가 뒤엉켜서 데이터를 예측 불가능하게 변경할 수 있으므로, 문제가 발생하기 쉽습니다.
- **경쟁 상태(Race Condition)**
  - 두 스레드 이상이 동일한 자원에 동시에 접근하여 값을 갱신할 때, 실행 순서에 따라 결과가 달라지는 상황입니다.
  - 락 또는 세마포어(Semaphore), 모니터(Monitor)와 같은 동기화 기법을 사용해 경쟁 상태를 제어해야 합니다.

## 3.2 데드락(Deadlock)과 교착 상태 해결 방안

- **데드락(Deadlock)**
  - 스레드 A와 스레드 B가 서로가 가진 락을 기다리며 무한 대기에 빠지는 현상을 말합니다.
  - “A가 락1을 잠근 상태로 락2를 요청, B가 락2를 잠근 상태로 락1을 요청”하는 전형적인 패턴이 대표적 예시입니다.
- **교착 상태 해결 방안**
  1. **락 획득 순서 지정**: 모든 스레드가 같은 순서로 락을 획득하도록 설계.
  2. **타임아웃(Time-out) 사용**: 일정 시간이 지나면 락 요청을 해제하고 재시도.
  3. **은행가 알고리즘(Banker’s Algorithm)**: OS 레벨에서 자원 할당 안전성을 사전에 계산.

---

# 4. 성능 최적화를 위한 멀티쓰레딩 설계

## 4.1 락 프리(lock-free) 데이터 구조

> “Lock-free data structures avoid the use of mutexes by using atomic operations like Compare-And-Swap (CAS).”

- **락 프리(lock-free)** 또는 **무락(lockless)** 알고리즘은 전통적인 뮤텍스 기반 잠금 없이도 스레드 안전성을 확보할 수 있도록 설계된 자료구조를 의미합니다.
- 예) **Lock-free queue**, **Lock-free stack**
- 대개 CPU가 제공하는 원자적(Atomic) 연산(CAS 등)을 활용해 경쟁 상태를 방지합니다.

## 4.2 동기화 대체 기술 (예: 이벤트 기반 모델)

- **이벤트 기반(Event-Driven) 모델**
  - 스레드를 여러 개 두는 대신, 이벤트 루프(Event Loop)를 통해 I/O 이벤트를 처리하는 기법.
  - Node.js처럼 단일 스레드 기반의 비동기 이벤트 처리 방식도 “스레드 락 문제”를 줄이고 높은 처리량을 달성할 수 있습니다.
- **신호 기반(Asynchronous Signal) 처리**
  - 비동기로 전달된 신호를 이벤트처럼 처리해, 메인 루프와 병렬로 동작시키는 구조.
  - 락 대신 메시지 전달 방식으로 스레드 간 협업.

---

# 5. 실제 사례와 멀티쓰레딩 도입 시 주의점

1. **웹 서버**
   - 아파치 HTTP 서버(기본적으로 프로세스 기반이지만, 쓰레드 풀 모듈 사용 가능), Nginx(이벤트 기반) 등은 각각의 장단점을 활용해 고성능을 달성합니다.
   - 쓰레드 풀(Thread Pool)을 사용해 요청마다 스레드를 생성하는 부담을 줄이거나, 이벤트 루프로 동시성을 확보하는 사례가 대표적입니다.
2. **게임 엔진**
   - 물리 연산, 렌더링, AI 처리 등 여러 모듈을 멀티쓰레드로 분산 실행합니다.
   - 동기화를 어떻게 효율적으로 할지(락 프리, 미세한 락 등)가 성능 핵심 포인트입니다.
3. **주의점**
   - **디버깅 복잡성**: 동시성 버그(경쟁 상태, 데드락 등)는 재현이 어려워 원인 파악이 쉽지 않습니다.
   - **테스트 전략**: 스트레스 테스트, 동시성 테스트를 꼼꼼히 진행해 잠재적 문제를 조기에 발견해야 합니다.
   - **오류 전이**: 한 스레드의 예외가 전체 프로세스를 중단시킬 수 있으므로, 에러 핸들링을 견고하게 설계해야 합니다.

---

# 마무리: 멀티쓰레딩을 효과적으로 활용하는 방법

멀티쓰레딩은 CPU 활용을 극대화하고 I/O 병목을 줄이는 동시에, 높은 응답성과 처리량을 제공할 수 있는 강력한 기법입니다.

다만, 아래와 같은 원칙을 항상 염두에 두어야 합니다.

1. **적절한 병렬화 대상 선정**
   - Amdahl’s Law에 비추어, 전체 작업 중 병렬 처리가 가장 효과적인 부분(병목 구간)에 집중합니다.
   - 병렬화로 얻는 이득이 동기화로 인한 오버헤드를 상회해야 의미가 있습니다.
2. **동기화 전략 수립**
   - 경쟁 상태를 피하기 위해 뮤텍스/세마포어/락 프리 자료구조 등을 적절히 활용합니다.
   - 복잡한 락 구조는 데드락 가능성을 높이므로 설계를 단순화하려는 노력이 필요합니다.
3. **오버헤드 최소화**
   - 스레드 수가 과도하면 컨텍스트 스위칭 비용만 늘어납니다.
   - 일반적으로 물리 코어 수를 크게 초과하는 스레드를 만들지 않도록 주의합니다.
4. **충분한 테스트와 모니터링**
   - 동시성 버그는 예측하기 어려운 순간에 발생할 수 있습니다.
   - 부하 테스트, 실시간 모니터링, 로그 분석 등을 통해 문제 상황을 조기에 감지해야 합니다.

결국, 멀티쓰레딩은 “이론적인 병렬 처리 장점”과 “실제 구현에서의 동기화 문제”가 공존하는 기술입니다. 잘 설계된 멀티쓰레드 구조는 뛰어난 성능과 응답성을 제공하지만, 설계와 디버깅이 까다롭고 운영체제·언어적 특성을 면밀히 고려해야 합니다.

따라서, 프로젝트의 요구사항(실시간성, 처리량, 안정성 등)에 비추어 적절히 계획하고 구현한다면 멀티쓰레딩의 이점을 극대화할 수 있을 것입니다.
