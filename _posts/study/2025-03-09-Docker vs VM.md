---
title: Docker란 무엇이고, VM과의 차이점?
date: 2025-03-09 00:10:00 +09:00
categories: [common_topic]
tags: [common]
# image: 
#   path:
---

## 1. 가상 머신(VM) 개요 및 등장 배경

가상 머신(Virtual Machine, VM)은 하나의 물리 서버 위에서 여러 사용자가 각자 독립적인 운영 체제를 실행할 수 있도록 **가상화** 기술을 이용해 구현된 환경입니다. 초기에는 여러 사용자가 하나의 물리 서버를 공유하면서 서로의 작업 간 충돌을 방지하고 안정적인 운영을 보장하기 위해 도입되었으며, 특히 하나의 게스트 OS 내에서 각 애플리케이션을 독립적으로 실행하여 애플리케이션 간 충돌 가능성을 줄이는 데 큰 역할을 했습니다.

### 1.1 VM의 정의와 역사

- **정의:**
물리적 하드웨어를 **가상화**하여, 각 게스트 OS가 독립된 환경에서 실행될 수 있도록 지원하는 기술입니다.
- **역사적 배경:**
초기 메인프레임 시대에 여러 사용자가 하나의 물리 서버를 공유하며 안정적이고 효율적으로 자원을 사용하기 위해 도입되었으며, 이후 클라우드 컴퓨팅 시대에 필수적인 인프라 기술로 발전하였습니다.

### 1.2 하이퍼바이저의 동작 원리 및 종류

- **하이퍼바이저(Hypervisor)**는 물리 서버의 리소스를 가상화하여 각 VM에 “가상 하드웨어”를 제공하는 소프트웨어입니다.
- **동작 원리:**
    - **자원 가상화:**
    물리적 CPU, 메모리, 저장장치, 네트워크 등 하드웨어 리소스를 추상화하여 각 VM에 할당합니다. 이를 통해 게스트 OS는 실제 하드웨어와 거의 동일한 “가상 하드웨어”를 사용하게 됩니다.
    - **격리 보장:**
    각 VM은 독립된 운영 체제와 커널을 사용하여 서로 간의 영향을 최소화합니다. 한 게스트 OS 내에서 하나의 애플리케이션만 작동시키면 애플리케이션 간 충돌이나 리소스 경합을 효과적으로 줄일 수 있습니다.
    - **동적 자원 할당:**
    하이퍼바이저는 리소스 오버커밋, 메모리 볼루닝, CPU 핀닝 등의 기법을 통해 VM의 필요에 따라 자원을 실시간으로 재분배하여 최적의 성능을 유지합니다.
- **하이퍼바이저의 종류:**
    - **타입 1 (Bare-metal):**
        - **예시:** VMware ESXi, Xen, Microsoft Hyper-V
        - **장점:** 물리 하드웨어 위에서 직접 실행되어 오버헤드가 적고, 보안성과 성능이 우수합니다.
        - **단점:** 전용 하드웨어와 전문적인 관리가 필요하며, 설정이 복잡할 수 있습니다.
    - **타입 2 (Hosted):**
        - **예시:** VMware Workstation, Oracle VirtualBox
        - **장점:** 기존 운영 체제 위에서 쉽게 설치 및 실행할 수 있어 사용자 친화적입니다.
        - **단점:** 호스트 OS의 성능과 보안에 의존하므로 타입 1에 비해 성능이 다소 떨어질 수 있습니다.

### 1.3 VM의 장점 및 단점

- **장점:**
    - **완전한 격리:**
    각 VM은 자체 운영 체제와 커널을 포함하여 높은 보안성과 안정성을 제공합니다.
    - **다양한 운영 체제 지원:**
    하나의 물리 서버에서 윈도우, 리눅스 등 서로 다른 운영 체제를 동시에 실행할 수 있습니다.
    - **애플리케이션 간 충돌 감소:**
    하나의 게스트 OS 내에서 각 애플리케이션을 분리 실행하여, 애플리케이션 간 충돌이나 리소스 경합을 효과적으로 줄입니다.
    - **유연한 자원 할당:**
    하이퍼바이저가 필요에 따라 동적으로 리소스를 재분배하여 최적의 성능을 유지합니다.
- **단점:**
    - **자원 오버헤드:**
    전체 운영 체제를 구동하기 때문에 메모리, CPU 등의 자원 소비가 많고 부팅 시간이 느립니다.
    - **관리 복잡성:**
    각 VM마다 운영 체제 업데이트, 패치, 보안 관리가 필요합니다.

---

## 2. Docker 개요 및 등장 배경

VM이 제공하는 높은 격리와 다양한 운영 체제 지원은 강점이지만, 전체 OS를 구동함에 따른 자원 소모와 배포 속도 문제 등 한계가 있었습니다. 이러한 한계를 극복하기 위해 보다 경량화된 컨테이너 기술인 Docker가 등장하였습니다.

### 2.1 Docker의 등장 배경 및 정의

- **등장 배경:**
    - VM의 오버헤드를 줄이고, 애플리케이션 단위로 빠른 배포와 확장을 위해 경량화된 솔루션이 요구되었습니다.
    - 예를 들어, Java 애플리케이션은 이미 JVM을 통해 가상 실행 환경을 제공받고 있으므로 Docker를 통해 더욱 일관되고 간소화된 배포 환경을 구축할 수 있습니다.
    - 반면, C++와 같이 시스템 프로그래밍이나 네이티브 성능이 중요한 애플리케이션의 경우, 언어 자체가 OS와 밀접하게 작동하므로 컨테이너화 시 추가적인 최적화나 고려가 필요할 수 있습니다.
- **정의:**
Docker는 애플리케이션과 그 종속성을 컨테이너라는 경량화된 격리 환경에 패키징하여, 개발부터 운영까지 동일한 실행 환경을 보장하는 플랫폼입니다.

### 2.2 Docker Engine의 동작 원리 및 실행 환경 통일성

- **Docker Engine의 역할:**
    
    Docker Engine은 컨테이너의 생성, 실행, 삭제 및 관리를 담당하는 핵심 소프트웨어입니다.
    
- **컨테이너 런타임:**
    
    Docker Engine은 호스트 OS의 커널을 공유하면서, 운영 체제에 따라 적합한 컨테이너 런타임(예: Linux 컨테이너 또는 Windows 컨테이너)을 자동으로 선택하고 실행합니다.
    
- **이미지와 Dockerfile:**
    
    애플리케이션, 라이브러리, 설정 파일 등을 포함한 Docker 이미지는 Dockerfile을 통해 정의되며, 이미지 내부에 모든 종속성이 패키징되어 있습니다.
    
- **실행 환경 통일성 제공 방식:**
    - **종속성 패키징:**
    Docker 이미지는 애플리케이션 실행에 필요한 모든 라이브러리, 설정 파일, 런타임 등을 함께 포함합니다.
    - **컨테이너 런타임 추상화:**
    Docker Engine은 Linux에서는 네임스페이스와 cgroups, Windows에서는 Windows Server Containers나 Hyper-V Containers를 활용하여 각 플랫폼에 맞는 격리와 자원 관리를 수행합니다.
    - **공통 API 제공:**
    모든 플랫폼에서 동일한 API와 CLI를 제공함으로써, 개발자가 OS 차이에 신경쓰지 않고 컨테이너를 실행하고 관리할 수 있습니다.
    - **베이스 이미지 선택:**
        
        일반적으로 Docker 이미지의 베이스 이미지는 Ubuntu, CentOS 등 리눅스 계열 배포판이 많이 사용됩니다. 이는 Docker Engine이 원래 리눅스 커널의 네임스페이스, cgroups 등 기능에 의존하여 설계되었기 때문입니다.
        
        그러나 반드시 리눅스 이미지만 선택해야 하는 것은 아닙니다.
        
        - **리눅스 컨테이너:** 리눅스 기반 이미지를 사용하며, 대부분의 경우 이 방식을 사용합니다.
        - **윈도우 컨테이너:** Windows 호스트에서 실행할 경우, `mcr.microsoft.com/windows/nanoserver` 등 Windows 기반 이미지를 사용할 수 있습니다.
    - **리눅스 기반 컨테이너:**
    기본적으로 Docker는 리눅스 OS 커널 기능(네임스페이스, cgroups)에 기반하여 작동합니다. Docker는 리눅스에서 애플리케이션의 코드, 라이브러리, 의존성, 설정 등을 관리하여 일관된 작업 환경을 제공합니다. 윈도우나 macOS에서는 Docker Desktop을 통해 내부 경량 리눅스 VM(예: WSL2, Hyper-V)을 활용함으로써 동일한 환경을 보장합니다.

### 2.3 Docker의 주요 기능 및 장점

- **경량화 및 빠른 시작:**
    
    전체 운영 체제를 포함하지 않고, 애플리케이션 실행에 필요한 최소 구성 요소만 포함하여 자원 소비와 초기화 시간이 크게 단축됩니다.
    
- **이식성:**
    
    동일한 Docker 이미지는 어느 환경에서나 같은 실행 조건을 보장하여, 개발 환경과 운영 환경 간의 불일치를 줄입니다.
    
- **효율적 배포 및 관리:**
    
    이미지 기반 배포, 버전 관리, CI/CD 자동화 도구와의 통합을 통해 운영 효율성이 크게 향상됩니다.
    
- **컨테이너 형식의 표준화:**
    
    Docker 컨테이너와 Kubernetes에서 관리되는 컨테이너화된 애플리케이션은 동일한 이미지 포맷과 설정 파일을 기반으로 생성되어 “같은 컨테이너”라는 전제 하에 일관된 개발 및 운영 환경을 유지할 수 있습니다.
    

---

## 3. VM과 Docker의 기술 비교

두 기술 모두 격리된 환경에서 애플리케이션을 실행하는 것을 목표로 하지만, 구현 방식과 운영 기법에는 뚜렷한 차이가 있습니다.

### 3.1 아키텍처 및 동작 방식 비교

- **VM:**
    - **구조:**
    하이퍼바이저가 물리적 리소스를 가상화하여 각 VM에 독립적인 운영 체제와 커널을 제공합니다. 이를 통해 한 게스트 OS 내에서 하나의 애플리케이션만 작동하게 하여, 애플리케이션 간 충돌이나 리소스 경합을 줄입니다.
    - **특징:**
    높은 보안성과 안정성을 제공하며, 다양한 운영 체제 지원이 가능하지만 자원 오버헤드가 큽니다.
- **Docker:**
    - **구조:**
    Docker Engine이 호스트 OS의 커널을 공유하면서, 컨테이너별로 애플리케이션과 그 종속성을 포함한 경량 환경을 생성합니다.
    - **특징:**
    Dockerfile을 통한 설정 관리로 동일한 실행 환경을 보장하며, 빠른 시작과 효율적 자원 활용이 가능합니다.

### 3.2 성능 및 자원 활용 측면

- **VM:**
    
    전체 운영 체제를 구동하기 때문에 메모리와 CPU 등의 자원 소비가 많으며, 부팅 및 초기화 속도가 느립니다.
    
- **Docker:**
    
    애플리케이션 실행에 필요한 최소 구성 요소만 포함하므로 오버헤드가 적어 동일 하드웨어에서 더 많은 컨테이너를 실행할 수 있습니다.
    

### 3.3 배포 및 관리 용이성

- **VM:**
    
    각 VM마다 운영 체제 관리, 보안 업데이트, 패치 등이 필요하여 배포 및 유지보수가 복잡합니다.
    
- **Docker:**
    
    이미지 기반 배포와 설정 파일 관리 덕분에 애플리케이션 업데이트 및 배포가 단순하며, 자동화 도구와 연동이 용이합니다.
    

### 3.4 보안 및 격리 측면

- **VM:**
    
    독립적인 운영 체제와 커널을 통해 높은 수준의 보안 격리를 제공합니다.
    
- **Docker:**
    
    호스트 OS의 커널을 공유하는 특성상, 컨테이너 간 격리 강화와 추가 보안 설정이 필요할 수 있습니다.
    

---

## 4. VM과 Docker 통합 및 하이브리드 환경과 Kubernetes의 역할

현대 IT 인프라는 VM과 Docker의 장점을 결합하여 하이브리드 환경을 구축하는 방향으로 발전하고 있으며, 이를 효과적으로 관리하기 위해 Kubernetes와 같은 오케스트레이션 도구가 핵심적인 역할을 수행합니다.

### 4.1 통합 운영 사례 및 사례 연구

- **통합 환경 구축:**
    
    기존 VM 기반 레거시 시스템은 보안성과 안정성을 유지하면서, 웹 애플리케이션이나 마이크로서비스는 Docker 컨테이너를 통해 빠르게 배포·확장하는 사례가 증가하고 있습니다.
    
- **사례 연구:**
    
    여러 클라우드 서비스 제공 업체들이 VM 위에 Docker 컨테이너를 배포하고, Kubernetes를 사용해 컨테이너의 자동 배포, 스케일링, 자원 관리를 구현함으로써 운영 효율성을 극대화하고 있습니다.
    

### 4.2 Kubernetes의 역할 및 개념

- **Kubernetes란?**
    
    Kubernetes는 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화하는 오픈 소스 플랫폼입니다.
    
- **주요 기능:**
    - **오케스트레이션:** 다수의 컨테이너를 클러스터 단위로 자동 배포하고 관리합니다.
    - **자동 스케일링:** 워크로드 변화에 따라 컨테이너 수를 자동으로 조정합니다.
    - **자원 관리:** 클러스터 내 자원을 효율적으로 분배하여 최적의 운영 환경을 유지합니다.
- **구성 요소 및 용어:**
    - **클러스터(Cluster):**
    여러 대의 서버(노드)를 하나의 그룹으로 묶어 컨트롤 플레인과 워커 노드로 구성된 관리 체계를 형성합니다.
    - **노드(Node):**
    클러스터를 구성하는 개별 서버로, 실제 컨테이너가 실행되는 단위입니다.
    - **워크로드(Workload):**
    쿠버네티스에서 배포되는 애플리케이션이나 서비스로, 파드(Pod), 디플로이먼트(Deployment) 등으로 정의됩니다.
    - **컨테이너 런타임 지원:**
    과거에는 Docker 컨테이너가 주로 사용되었으나, Kubernetes는 containerd, CRI-O 등 다양한 컨테이너 런타임을 지원합니다.

### 4.3 하이브리드 인프라 구축 전략

- **이중화 및 자동화:**
    
    보안과 안정성이 중요한 핵심 서비스는 VM으로 운영하고, 빠른 배포와 확장이 필요한 웹 및 마이크로서비스는 Docker와 Kubernetes를 결합하여 운영합니다.
    
- **통합 관리 도구:**
    
    VM 관리 시스템과 Kubernetes를 연계하여 전체 인프라의 상태를 실시간으로 모니터링하고, 자동화된 배포 시스템을 구축합니다.
    

### 4.4 고려사항 및 결론

- **종합 장단점:**
    - **VM의 강점:** 완전한 격리, 다양한 운영 체제 지원, 높은 보안성, 애플리케이션 간 충돌 감소
    - **Docker의 강점:** 경량화, 빠른 배포, 일관된 실행 환경(설정 파일 기반 정의), 자원 효율성
    - **Kubernetes의 역할:** 대규모 컨테이너 환경을 자동으로 관리하고, 스케일링 및 자원 최적화를 지원하여 하이브리드 인프라 운영의 핵심 역할을 수행
- **미래 전망:**
VM과 Docker의 장점을 결합하고, Kubernetes와 같은 오케스트레이션 도구를 통한 통합 관리는 클라우드 및 마이크로서비스 아키텍처 시대에 안정적이고 확장 가능한 인프라 구축의 핵심 전략으로 자리잡을 것입니다.

---

## 추가: 하이퍼바이저의 Guest OS 관리 기법 및 Docker 컨테이너의 격리 기술

### 하이퍼바이저와 Guest OS 관리 기법

- **자원 가상화 및 추상화:**
    
    하이퍼바이저는 물리적 CPU, 메모리, 저장장치, 네트워크 등 하드웨어 리소스를 추상화하여 각 Guest OS에 “가상 하드웨어”로 제공, 게스트 OS가 독립적인 환경에서 실행되도록 지원합니다.
    
- **격리 및 보안:**
    
    하이퍼바이저는 각 Guest OS를 서로 격리하여, 하나의 VM에서 발생하는 문제가 다른 VM에 영향을 미치지 않도록 보장합니다.
    
- **동적 자원 할당 및 스케줄링:**
    - **리소스 오버커밋:** 실제 물리 자원보다 많은 가상 자원을 할당하여, 사용량이 낮을 때 자원을 효율적으로 분배합니다.
    - **메모리 볼루닝:** 사용하지 않는 메모리를 회수해 다른 VM에 재할당할 수 있도록 지원합니다.
    - **CPU 핀닝:** 특정 CPU 코어에 VM을 고정시켜 예측 가능한 성능을 보장합니다.
- **스냅샷 및 라이브 마이그레이션:**
    
    하이퍼바이저는 Guest OS의 현재 상태를 스냅샷으로 저장하거나, 실행 중인 VM을 다른 물리 서버로 실시간 이전하는 기능을 제공하여 백업, 장애 복구 및 유지보수에 활용됩니다.
    
- **중앙 집중식 관리 도구:**
    
    다수의 하이퍼바이저 솔루션은 중앙에서 여러 VM의 상태, 자원 사용, 성능, 보안 업데이트 등을 모니터링하고 관리할 수 있는 도구를 제공합니다.
    

### Docker 컨테이너의 격리 기술

- **네임스페이스 (Namespaces):**
    
    리눅스 커널 기능으로, 컨테이너마다 독립된 가상 리소스 공간을 제공합니다.
    
    - **PID 네임스페이스:** 각 컨테이너는 독립적인 프로세스 ID 공간을 가지며, 컨테이너 내부의 프로세스는 그 컨테이너 외부의 프로세스를 볼 수 없습니다.
    - **네트워크 네임스페이스:** 각 컨테이너는 자체 가상 네트워크 스택(가상 NIC, IP, 포트)을 가지며, 다른 컨테이너나 호스트와 격리되어 동작합니다.
    - **마운트 네임스페이스:** 컨테이너는 독립된 파일시스템 뷰를 사용해, 호스트 파일시스템과 분리된 환경을 제공합니다.
    - **IPC 네임스페이스:** 세마포어, 메시지 큐, 공유 메모리 등 인터프로세스 통신 리소스를 컨테이너별로 격리합니다.
    - **UTS 네임스페이스:** 컨테이너마다 개별의 호스트 이름 및 도메인 이름을 설정할 수 있어, 서로 간섭하지 않습니다.
- **Cgroups (Control Groups):**
    
    리눅스 커널 기능으로, 컨테이너별로 CPU, 메모리, I/O 등의 자원 사용량을 제한하고 모니터링할 수 있습니다.
    
    - 예를 들어, 컨테이너의 메모리 사용량을 제한(--memory)하거나 CPU 사용량(--cpus)을 설정해, 한 컨테이너가 시스템 자원을 독점하지 못하도록 합니다.
    - 이를 통해 자원 누수나 폭주 등의 상황이 발생해도 전체 시스템에 영향을 미치지 않도록 격리합니다.